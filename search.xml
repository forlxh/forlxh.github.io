<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[剑指offer面试题14--剪绳子]]></title>
    <url>%2F2019%2F09%2F19%2F%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9814-%E5%89%AA%E7%BB%B3%E5%AD%90%2F</url>
    <content type="text"><![CDATA[剑指offer面试题14–剪绳子 给你一根长度为n的绳子，把绳子剪成m段（m、n都是整数且m &gt; 1, n &gt; 1）,m段绳子的长度依然是整数，求m段绳子的长度乘积最大为多少？比如绳子长度为8，我们可以分成2段、3段、4段…8段，只有分成3段且长度分别是2、3、3时能得到最大乘积18 动态规划版本要求大问题的最优解，可以将大问题分解成小问题，分解的小问题也有最优解，因此将小问题的最优解组合起来就能得到大问题的最优解。若将f(n)定义为将长度为n的绳子分成若干段后的各段长度的最大乘积（最优解），在剪第一刀时有n-1种剪法，可选择在0 &lt; i &lt; n处下刀；如在i处下刀，分成长度为i的左半绳子和长度为n - i的右半绳子，对于这两根绳子，定义最优解为f(i)和f(n-i)，于是f(n) = max(f(i) * f(n-i))，即求出各种相乘可能中的最大值就是f(n)的最优解。这两根绳子又可以继续分下去，就这样从上到下的分下去，但是问题的解决得从下到上来。因为f(2)、f(3)的很好求： f(2) = 1，因为只能分成两半 f(3) = 2，因为分成两段2*1 大于分成三段的1*1*1 然后根据这两个最优解求出f(4)、f(5)…直到f(n)，每个f(i)的确定是通过遍历所有可能的相乘情况，从中选出乘积最大者。 1234567891011121314151617181920212223242526272829303132333435package cn.localhost.interview14;public class CutRope &#123; public static int maxProductAfterCutting(int length) &#123; if (length &lt; 2) return 0; if (length == 2) return 1; if (length == 3) return 2; // productt[0]不使用，使用product[length] int[] products = new int[length + 1]; products[1] = 1; products[2] = 2; products[3] = 3; // 从products[4]到products[length]放的是f(4)~f(n)的值 for (int i = 4; i &lt;= length; i++) &#123; int max = 0; // 对所有相乘情况进行遍历求出f(i)的最优解 for (int j = 1; j &lt;= i / 2; j++) &#123; int product = products[j] * products[i - j]; if (product &gt; max) max = product; &#125; // 得到f(i)的最优解 products[i] = max; &#125; // 返回f(n) return products[length]; &#125;&#125; 对于长度为2或者3的绳子，可以直接返回答案。之后f(4)f(n)的值存放在了products[4]products[n]中，注意product[1]products[3]中存放的不是f(1)f(3)，它们单纯地表示长度而已，作为求出f(i)，4 &lt;= i &lt;= n的辅助。最后得到的f(n)存放在products[n]中，直接返回即可。第二层中的for循环为了得到f(i)，遍历了所有可能的乘积情况，将最大乘积赋予max。j &lt;= i / 2是为了避免重复的相乘情况，比如i = 4时，只有2*2和1*3两种，3*1和1*3是同一种相乘情况，所以j只到i / 2 = 2即可枚举所有相乘情况。 贪婪算法我们应用贪婪算法解决问题时，每一步都可以做出一个贪婪的选择。基于这个选择，我们确定能得到问题的最优解。为什么能得到最优解，还需要数学证明来保证。 这道题我们按照下面的做法就能得到最优解：如果绳子长度n &gt;= 5，就不断分出长度为3的绳子，如果最后只剩下长度为1的绳子，退一步，将得到长度为4的绳子，然后将这长度为4的绳子分成2*2(这样分是因为2*2大于原来的3*1)；因此n = 4时不能分出长度为3的绳子,而n = 2，n = 3的最优解可直接返回。 当n &gt;=5时，满足该不等式的满足i*(n-i) &gt; n的只有2*(n-2) &gt; n以及3*(n-3) &gt; n，注意i+n-2 = n，也就是说分出的两个相乘的数要满足和为n，且给定同样的n，3*(n-3)的值更大，这就是为什么要不断分出长度为3的绳子的原因。 基于此写出代码。 123456789101112131415161718192021222324package cn.localhost.interview14;public class CutRope &#123; public static int maxProductAfterCutting2(int length) &#123; if (length &lt; 2) return 0; if (length == 2) return 1; if (length == 3) return 2; // 统计能分出多少段长度为3的绳子 int timesOf3 = length / 3; // 如果最有只剩下长度为1的绳子，需要退一步，得到长度为4的绳子，重新分成2*2的 if (length - timesOf3 * 3 == 1) &#123; timesOf3--; &#125; // 统计能分出多少段长度为2的绳子 // 到这步length - timesOf3 * 3的值只可能是0,2,4，所以timesOf2只可能是0, 1, 2 int timesOf2 = (length - timesOf3 * 3) / 2; return (int) Math.pow(3, timesOf3) * (int) Math.pow(2, timesOf2); &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建型模式]]></title>
    <url>%2F2019%2F09%2F19%2F%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[创建型模式的主要特点是什么？创建型模式(Creational Pattern)==对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离==。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。创建型模式在创建什么(What)，由谁创建(Who)，何时创建(When)等方面都为软件设计者提供了尽可能大的灵活性。创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。 它的主要特点是“==将对象的创建与使用分离==”，这样可以降低系统的耦合度。 创建型模式分为以下几种：==单件（Singleton）模式==：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。 ==工厂方法（Factory Method）模式==：定义一个用于创建产品的接口，由子类决定生产什么产品。 ==抽象工厂（Abstract Factory）模式==：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。 简单工厂模式模式动机考虑一个简单的软件应用场景，一个软件系统可以提供多个外观不同的按钮（如圆形按钮、矩形按钮、菱形按钮等）， 这些按钮都源自同一个基类，不过在继承基类后不同的子类修改了部分属性从而使得它们可以呈现不同的外观，如果我们希望在使用这些按钮时，不需要知道这些具体按钮类的名字，只需要知道表示该按钮类的一个参数，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的按钮对象，此时，就可以使用简单工厂模式。 模式定义简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 模式结构Factory：工厂角色，是负责实现创建所有实例的内部逻辑 Product：抽象产品角色，是所创建的所有对象的父类，负责描述所有实例所共有的公共接口 ConcreteProduct：具体产品角色，是创建目标，所有创建的对象都充当这个角色的某个具体类的实例 模式实例123456789101112131415161718192021222324252627public abstract class Animal &#123; public abstract void eat();&#125;public class Dog extends Animal &#123; public void eat() &#123; System.out.println("狗吃肉"); &#125;&#125;public class Cat extends Animal &#123; public void eat() &#123; System.out.println("猫吃鱼"); &#125;&#125;public class AnimalFactory &#123; private AnimalFactory() &#123;&#125; public static Animal createAnimal(String type) &#123; if ("dog".equals(type)) &#123; return new Dog(); &#125; else if ("cat".equals(type)) &#123; return new Cat(); &#125; else &#123; return null; &#125; &#125;&#125; 模式优缺点优点： 工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性 缺点： 由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。 使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。 模式应用 JDK类库中广泛使用了简单工厂模式，如工具类java.text.DateFormat，它用于格式化一个本地日期或者时间。 1234public final static DateFormat getDateInstance();public final static DateFormat getDateInstance(int style);public final static DateFormat getDateInstance(int style,Localelocale); Java加密技术 工厂方法模式模式定义定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作要求具体子工厂类实现。这满足创建型模式中所要求的“创建与使用相分离”的特点。 模式优缺点优点：1）用户知道具体工厂的名称就可得到所要的产品，无须知道产品的创建过程；2）增加新的产品时只需要添加具体产品类和对应的具体工厂类，无需修改源代码，满足开闭原则。 缺点：每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。 模式结构工厂方法模式的主要角色有： 抽象工厂(Abstract Factory)：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法newProduct()来创建产品。 具体工厂(Concrete Factory)：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。 抽象产品(Product)：定义了产品的规范，描述了产品的主要特性和功能。 具体产品(Concrete Product)：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。 模式类图 模式适用环境客户只知道创建产品的工厂名,而不知道具体的产品名。如：海尔工厂、美的工厂等；但注意产品都是同等级的。 创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。 客户不关心创建产品的细节，只关心产品的品牌。 模式拓展当需要生成的产品不多且不会增加，一个具体工厂类就可以完成任务时，可删除抽象工厂类。这时工厂方法模式将退化到简单工厂模式。 简单工厂模式违反开闭原则，不多说。 抽象工厂模式模式动机 在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法也具有唯一性，一般情况下，一个具体工厂中只有一个工厂方法或者一组重载的工厂方法。但是有时候我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象。 为了更清晰地理解工厂方法模式，需要先引入两个概念： 产品等级结构 ：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。 产品族 ：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。 当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品时需要使用抽象工厂模式。 抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。 抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建 。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。 ： 模式定义​ 抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。 模式优缺点优点： 可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理； 当增加一个新的产品族时不需要修改原代码，满足开闭原则。 缺点：当产品族中需要增加一个新等级的产品时，则所有的工厂类都需要进行修改。 模式结构抽象工厂模式的主要角色有： 抽象工厂(Abstract Factory)：提供了创建产品的接口，它包含多个创建产品的方法newProduct()，可以创建多个不同等级的产品。 具体工厂(Concrete Factory)：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。 抽象产品(Product)：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。 具体产品(Concrete Product)：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是==多对一==的关系。 抽象工厂的应用场景抽象工厂模式通常适用以下场景： 当需要创建的对象是一系列相互关联或相互依赖的产品族时，如：电器工厂中的电视机、洗衣机、空调等。 系统中有多个产品族，但每次只使用其中的某一族产品。如：有的粉丝只喜欢穿李宁牌的衣、裤和鞋。 系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。 抽象工厂模式的扩展抽象工厂模式的扩展有一定的“开闭原则”倾斜性： 当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。 当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则。 另一方面，当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式。 单例模式模式动机对于系统中的某些类来说，只有一个实例很重要，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID（序号）生成器。 如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。 一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。 模式定义单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。 模式特点单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。 模式类图 模式代码饿汉式 1234567public class SingleTon&#123; private static SingleTon singleton = new SingleTon(); private SingleTon()&#123;&#125; public static SingleTon getInstance()&#123; return singleton; &#125;&#125; 懒汉式 12345678910111213141516171819202122232425262728293031323334353637383940public class SingleTon &#123; //由于对象需要被静态方法调用,把方法设置为static //由于对象是static,必须要设置访问权限修饰符为private ,如果是public可以直接调用对象,不执行访问入口 private static SingleTon singleton; /** * 方法名和类名相同 * 无返回值. * * * 其他类不能实例化这个类对象 * * 对外提供访问入口 */ private SingleTon()&#123;&#125; /** * 实例方法,实例方法必须通过对象调用 * * 设置方法为静态方法 * * * @return */ public static SingleTon getInstance()&#123; //添加逻辑如果实例化过,直接返回 if(singleton==null)&#123; /* * 多线程访问下,可能出现if同时成立的情况,添加锁 */ synchronized (SingleTon.class) &#123; //双重验证 if(singleton==null)&#123; singleton = new SingleTon(); &#125; &#125; &#125; return singleton; &#125;&#125; 模式实例在操作系统中，打印池(Print Spooler)是一个用于管理打印任务的应用程序，通过打印池用户可以删除、中止或者改变打印任务的优先级，在一个系统中只允许运行一个打印池对象，如果重复创建打印池则抛出异常。现使用单例模式来模拟实现打印池的设计。 建造者模式模式动机复杂对象相当于一辆有待建造的汽车，而对象的属性相当于汽车的部件，建造产品的过程就相当于组合部件的过程。由于组合部件的过程很复杂，因此，这些部件的组合过程往往被“外部化”到一个称作建造者的对象里，建造者返还给客户端的是一个已经建造完毕的完整产品对象，而用户无须关心该对象所包含的属性以及它们的组装方式，这就是建造者模式的模式动机。 可以通过建造者模式对其进行设计与描述，建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。 模式定义建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 模式结构 Builder：抽象建造者 ConcreteBuilder：具体建造者 Director：指挥者 Product：产品角色 模式分析抽象建造者类中定义了产品的创建方法和返回方法。 建造者模式的结构中还引入了一个指挥者类Director，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。 模式实例实例：KFC套餐 建造者模式可以用于描述KFC如何创建套餐：套餐是一个复杂对象，它一般包含主食（如汉堡、鸡肉卷等）和饮料（如果汁、 可乐等）等组成部分，不同的套餐有不同的组成部分，而KFC的服务员可以根据顾客的要求，一步一步装配这些组成部分，构造一份完整的套餐，然后返回给顾客。 模式代码1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Product&#123; private String partA; private String partB; //get和set方法&#125;public interface Builder&#123; public void buildPartA(); public void buildPartB(); public Product retrieveResult();&#125;public class ConcreteBuilder implements Builder&#123; private Product product = new Product(); public void buildPartA()&#123; product.setPartA("编号：1101"); &#125; public void buildPartB()&#123; product.setPartB("名称：发动机"); &#125; public Product retrieveResult()&#123; return product; &#125;&#125;public class Director&#123; private Builder builder; public Director(Builder builder)&#123; this.builder=builder; &#125; public void construct()&#123; builder.builderPartA(); builder.builderPartB(); &#125;&#125;public class Client &#123; public static void main(String[]args)&#123; Builder builder = new ConcreteBuilder(); Director director = new Director(builder); director.construct(); Product product = builder.retrieveResult(); System.out.println(product.getPart1()); System.out.println(product.getPart2()); &#125;&#125; 模式优缺点优点： 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。 用户使用不同的具体建造者即可得到不同的产品对象。 可以更加精细地控制产品的创建过程。 增加新的具体建造者无须修改原有类库的代码，指挥者针对抽象建造者类编程，系统扩展方便，符合开闭原则。 缺点： 使用范围受到一定限制。如果产品之间的差异性很大，则不适合用建造者模式。 如果产品内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得庞大。 建造者模式与抽象工厂模式比较建造者模式返回一个组装好的完整产品，而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成一个产品族。 如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，n那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象设计原则]]></title>
    <url>%2F2019%2F09%2F19%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[面向对象设计原则开闭原则对扩展开放，对修改关闭 开闭原则是面向对象设计的核心所在，遵循这个原则可以带来面向对象技术所声称的巨大好处：可维护，可扩展，可复用，灵活性好。 单一职责原则就是一个类而言，应该仅有一个引起它变化的原因 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。 依赖倒转原则抽象不应该依赖细节，细节应该依赖于抽象（针对接口编程，不要对类实现编程） ​ 高层模块不应该依赖于底层模块。两个都应该依赖于抽象 里氏替换原则子类型必须能替换掉它们的父类型 只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。 由于子类的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展 正是有了里氏替换原则，才使得开闭原则成为了可能 接口隔离原则这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使 用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好 迪米特法则 如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。 ​ 在类的结构设计上，每一个类都应当尽量降低成员的访问权限。 ​ 迪米特法则强调了类之间的松耦合。类之间的耦合越弱，越有利于复用，一个处于弱耦合的类被修改，不会对有关系的类造成波及。 合成复用原则原则是尽量首先使用合成/聚合的方式，而不是使用继承 设计模型的分类根据目标分类创建型：关注对象的创建过程 结构型：处理类和对象的组合结构 行为型：给出类或对象交互的方式和职责分配 根据范围分类类范围：关注类、子类之间的关系，侧重静态 对象范围：关注对象之间的关系，更加侧重动态和运行时的改变]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML类图]]></title>
    <url>%2F2019%2F09%2F19%2FUML%E7%B1%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[UML类图的相关知识泛化关系(generalization)类的继承结构表现在UML中为：泛化(generalize)与实现(realize)： 继承关系为 is-a的关系；两个对象之间如果可以用 is-a 来表示，就是继承关系：（..是..) eg：自行车是车、猫是动物 泛化关系用一条带空心箭头的直接表示；如下图表示（A继承自B） 实现关系(realize)实现关系用一条带空心箭头的虚线表示； eg：”车”为一个抽象概念，在现实中并无法直接用来定义对象；只有指明具体的子类(汽车还是自行车)，才 可以用来定义对象（”车”这个类在C++中用抽象类表示，在JAVA中有接口这个概念，更容易理解） 聚合关系(aggregation)聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成。 聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成。 与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在。 组合关系(composition)组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成。 与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成。 但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了。 关联关系(association)关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；==它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的==；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系； 比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系； ==关联关系默认不强调方向，表示对象间相互知道==；如果特别强调方向，如下图，表示A知道B，但 B不知道A； 注：在最终代码中，关联对象通常是以==成员变量的形式==实现的； 依赖关系(dependency)依赖关系是用一套带箭头的虚线表示的；如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系； 与关联关系不同的是，==它是一种临时性的关系==，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化； 显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生； 注：在最终代码中，依赖关系体现为类构造方法及类方法的==传入参数==，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是==“使用”对方的方法和属性==； 类的表示：矩形框：代表一个类，类图分三层第一层显示类的名称：抽象类用斜体 第二层是类的特性：字段和属性 第三层是类的操作：方法或行为（+:public；-:private；#:protected，~:default（可省略）） ​ 斜体代表抽象，下划线代表静态 接口的表示：矩形框，顶部有《interface》]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer面试题13--机器人的运动范围]]></title>
    <url>%2F2019%2F09%2F19%2F%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9813-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4%2F</url>
    <content type="text"><![CDATA[剑指offer面试题13–机器人的运动范围 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 此题和面试题12——矩阵中的路径有相似之处，依然是回溯法。每来到一个新的且满足条件的格子时，计数加1。除矩形的边界外，任意一个方格都有四个方向可以选择，选择任一方向后来到新的格子又可以选择四个方向，但是一个到达过的格子不能进入两次，因为这将导致对同一个格子的重复计数。也就是说，一个格子一旦满足条件进入后，就被永久标记为“访问过”，一个满足条件的格子只能使计数值加1。这是和面试题12有区别的地方（那个例子中是搜索路径，失败路径上的点要重新标记为“未访问”，因为另开辟的新路径需要探索这些点）。 这道题用通俗的话来讲就是：m行n列的所有方格中，有多少个满足行坐标和列坐标的数位之和小于等于门限值k的格子？ 代码和面试题12长得有点像，但是两个问题是有明显区别的！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package Chap2;public class RobotMove &#123; public int movingCount(int threshold, int rows, int cols) &#123; if (rows &lt;= 0 || cols &lt;= 0 || threshold &lt; 0) &#123; return 0; &#125; boolean[] marked = new boolean[rows * cols]; // 从(0, 0)处开始 return move(0, 0, threshold, rows, cols, marked); &#125; /** * 递归方法，每到一个格子就四个方向搜索 * * @param row 当前行 * @param col 当前列 * @param threshold 门限值 * @param rows 总行数 * @param cols 总列数 * @param marked 是否访问过 * @return 当前格子数(等于1)加上4个方向能访问到的格子数的总和 */ private int move(int row, int col, int threshold, int rows, int cols, boolean[] marked) &#123; int count = 0; if (checked(row, col, threshold, rows, cols, marked)) &#123; marked[row * cols + col] = true; // 递归对四个方向计数，注意四个方向的搜索不是同时发生， count = move(row - 1, col, threshold, rows, cols, marked) + move(row + 1, col, threshold, rows, cols, marked) + move(row, col - 1, threshold, rows, cols, marked) + move(row, col + 1, threshold, rows, cols, marked) + 1; &#125; return count; &#125; /** * 判断当前格子是否超过门限值，以及边界值的判断 * * @return true如果当前格子满足条件 */ private boolean checked(int row, int col, int threshold, int rows, int cols, boolean[] marked) &#123; return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; cols &amp;&amp; !marked[row * cols + col] &amp;&amp; digitSum(row) + digitSum(col) &lt;= threshold; &#125; /** * 比如数字1234,每位数相加的和将返回10 * @param number 某数字 * @return 该数字的数位之和 */ private int digitSum(int number) &#123; int sum = 0; while (number &gt; 0) &#123; sum += number % 10; number /= 10; &#125; return sum; &#125;&#125; checked方法用于判断当前坐标是否满足边界条件，是否超过门限值。 递归方法move是核心，注意递归对四个方向计数时，四个方向的搜索不是同时发生的，一个方向搜索失败（遇到边界或超过门限值）后，退回来进行下一个方向的搜索，回溯法就体现在此。]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer面试题12--矩阵中的路径]]></title>
    <url>%2F2019%2F09%2F18%2F%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9812-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[剑指offer面试题12–矩阵中的路径 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如下面矩阵 a b t g c f c s j d e h 包含一条字符串”bfce”的路径，但是矩阵中不包含”abfb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 这有点像图的深度优先搜索。除了矩阵边界，每个点都可以在4个方向上选择任意一个前进。当某一条路径失败后，需要回溯到上一次选择处，选择另一个方向再尝试。如果该处的方向都被尝试过了，继续回溯到上次选择处…每一次选择都会来到一个新的格子，在这个格子处又有若干个方向可选择，就这样不断前进、回溯、再前进，直到找到一条满足要求的路径为止；如果所有点都作为起点搜索一遍后还是没有找到满足要求的路径，说明在这个矩阵中不存在该条路径。 上面的描述，使用递归比较好理解。还有一点需要注意，由于路径上访问过的点不能进入第二次，所以需要一个boolean[] marked标记那些当前路径上被访问过的点。 12345678910111213141516171819202122232425262728293031323334353637383940414243package Chap2;public class PathIn2DArray &#123; public boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123; if (matrix == null || rows &lt;= 0|| cols &lt;=0 || str == null) return false; // 用于将当前路径上的访问过的点标记为“已访问”，防止同一个点访问两次 boolean[] marked = new boolean[matrix.length]; // 所有点都作为起点搜索一次 for (int row = 0; row &lt; rows; row++) &#123; for (int col = 0; col &lt; cols; col++) &#123; if (hasPathTo(matrix, rows, cols, row, col, str, 0, marked)) &#123; return true; &#125; &#125; &#125; return false; &#125; private boolean hasPathTo(char[] matrix, int rows, int cols, int row, int col, char[] str, int len, boolean[] marked) &#123; // 由于用一维数组表示二维矩阵，第row行第col列，就是row * cols + col int index = row * cols + col; if (row &lt; 0 || row &gt;= rows || col &lt; 0 || col &gt;= cols || matrix[index] != str[len] || marked[index]) &#123; return false; &#125; // 递归深度能到字符串末尾，说明有这条路径 if (len == str.length - 1) &#123; return true; &#125; marked[index] = true; // 四个方向上有没有可以到达下一个字符的路径，有任意一个方向可以就继续下一个字符的搜索 if (hasPathTo(matrix, rows, cols, row, col - 1, str, len + 1, marked) || hasPathTo(matrix, rows, cols, row - 1, col, str, len + 1, marked) || hasPathTo(matrix, rows, cols, row, col + 1, str, len + 1, marked) || hasPathTo(matrix, rows, cols, row + 1, col, str, len + 1, marked)) &#123; return true; &#125; // 对于搜索失败需要回溯的路径上的点，则要重新标记为“未访问”，方便另辟蹊径时能访问到 marked[index] = false; return false; &#125;&#125; 递归方法hasPathTo中有个参数len，它表示当前递归的深度。第一次调用传入0，之后在其基础上的每一次递归调用len都会加1，递归的深度也反映了当前路径上有几个字符匹配相等了。能绕过下面的if判断，说明当前字符匹配相等了。接下来判断递归深度是否到达字符串末尾，比如字符串abc，第一次调用hasPath（传入len为0，递归深度为0）绕过了第一个if，说明字符a已经匹配相等，再判断len == str.length - 1不通过；再次递归，此时深度为1，绕过了第一个if，说明字符b已经匹配相等，再判断len == str.length - 1不通过；再次递归，此时深度为2，绕过了第一个if，说明字符c已经匹配相等，所有字符匹配相等，因此再次判断len == str.length - 1通过，应该返回true. 12345678if (row &lt; 0 || row &gt;= rows || col &lt; 0 || col &gt;= cols || matrix[index] != str[len] || marked[index]) &#123; return false;&#125;// 递归深度能到字符串末尾，说明有这条路径if (len == str.length - 1) &#123; return true;&#125; 还有注意：四个方向搜索不是同时发生的，当某一个方向搜索失败后，会退回来进行下一个方向的搜索，回溯法就体现在此。 当搜索失败时，别忘了marked[index] = false;，将搜索失败路径上点重新标记为“未访问”，以便回溯后选择其他方向继续前进时能再次访问到这些点。]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer面试题11--旋转数组中的最小数字]]></title>
    <url>%2F2019%2F09%2F18%2F%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9811-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[剑指offer面试题11–旋转数组中的最小数字 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 题目给出的是非递减排序数组，所以不是严格递增的，可能有相同元素的情况。 顺序遍历我的解法：两个子数组都是递增的，只有在两个子数组的分界线处，才会有前一个字符大于后一个字符。时间复杂度为O(n) 123456789public int minNumberInRotateArray(int[] array)&#123; if(array.length == 0) return 0; for(int i = 0;i&lt;array.length-1;i++)&#123; if(array[i]&gt;array[i+1]) return array[i+1]; &#125; return array[0];&#125; 二分查找由于有序数组旋转后，被分成了两个有序的子数组，因此可以用二分查找，且左半数组的值全大于等于右半数组的值。我们要找的最小元素恰好是右半数组的第一个元素，或者说左半数组末尾后一个元素。 和二分查找一样，一个指针low指向数组首元素，一个high指向尾元素。还有一个指针mid，这里注意：mid不是要和哪个特定的值比较来缩小范围，根据旋转数组的特点，我们始终将mid和high处的值比较。分三种情况 array[mid] &gt; array[high];此时mid一定还处于左半数组中，而要找的最小值在右半数组中，最小值肯定在mid的右边，所以可以直接将low移动到mid的下一个位置，即low = mid + 1。举个例子{3, 4, 5, 1, 2}，mid处的5比high处的2大，直接更新low = 3，数组被缩小到{1, 2} array[mid] &lt; array[high];此时mid一定处于右半数组中，最小值可能在mid处也可能在mid的左边。所以high只能缩小到mid处，即high = low。举个例子{4, 5, 1, 2, 3}，mid处的1小于high处的3，只能将high移动到1处，数组缩小为{4, 5, 1}，如果像上面类似令high = mid - 1，最小值再这个例子中就被跳过了！ array[mid] == array[high];此时无法分辨mid处于左半数组还是右半数组。比如{1, 0, 1, 1, 1}和{1, 1, 1, 0, 1}都是数组{0, 1, 1, 1, 1}的旋转数组。此时mid处和high处的值一样，若根据low缩小范围，对于{1, 0, 1, 1, 1}最小值将被跳过；如果根据high缩小范围，对于{1, 1, 1, 0, 1}最小值也会被跳过。此时的处理方法是暂时放弃二分查找，既然mid处和high处值相同，那么让high--，让mid和high的前一个值继续比较。如果mid和high处都是最小值，就算放弃了high最后还是会在mid处找到最小值。 只要low &lt; high(不含等于)，就不断重复上面过程，最后将范围缩小到只有一个元素后，low == high跳出循环。其实low == high时候还进入循环，也没有错，此时只会造成high–，而我们返回的是array[low]，值不会影响，但是何必进行这次无意义的比较呢。 根据上面的描述已经可以写出代码了。 1234567891011121314151617181920public class MinNumberInRotateArray&#123; public int minNumberInRotateArray(int[] array)&#123; if(array == null || array.length == 0)&#123; return 0; &#125; int low = 0; int high = array.length-1; while(low&lt;high)&#123; int mid = low+(high-low)/2; if(array[mind]&gt;array[high]) low = mid+1; else if(array[mid]&lt;array[high]) high = mid; else high--; &#125; // low == high时退出循环并返回 return array[low]; &#125;&#125; 时间复杂度为O(lg n)。 上面始终将mid和high比较，可不可以mid和low比较呢，可以但是和与high比较相比更麻烦。 试想如果最后范围缩小到剩下{1, 2}此时array[low] == array[mid]，如果low++就跳过最小元素了，此种情况可以写一个min(int low, int high)方法，直接返回[low, high]范围内的最小值。比起用high来和mid比较，麻烦了不少。]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer面试题10--斐波那契数列]]></title>
    <url>%2F2019%2F09%2F18%2F%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9810-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[剑指offer面试题10–斐波那契数列 现在要求输入一个整数n，请你输出斐波那契数列的第n项。 我想到的是迭代法，从底向上的方法：先得到f(0)、f(1)的值，然后根据这两个值计算序列后面的值。 迭代法123456789101112131415public class Fibonacci&#123; //推荐迭代法 public static int fib(int n)&#123; if(n&lt;=0) return 0; int a = 0; int b = 1; while(n&gt;0)&#123; b = a + b; a = b - a; n--; &#125; return a; &#125;&#125; 当然还有递归法，时空开销较大，有大量重复计算，不推荐。 递归法1234567public static int fib2(int n)&#123; if(n&lt;=0) return 0; if(n==1) return 1; return fib2(n-1)+fib2(n-2);&#125; 相关题目–青蛙跳台阶 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 到达1级台阶只有1种可能，到达2级台阶有2种可能；可记为f(1) = 1,f(2) = 2。要到达3级台阶，可以选择在1级台阶处起跳，也可以选择在2级台阶处起跳，所以只需求到达1级台阶的可能情况 + 到达2级台阶的可能情况，即f(3) = f(2) +f(1) 同理到达n级台阶，可以在n-1级台阶起跳，也可在n-2级台阶起跳，f(n) = f(n-2)+f(n-1) 可以看做是斐波那契数列。 12345678910111213141516public class JumpFloor&#123; public static int jumpFloor(int target)&#123; if(target&lt;=0) return 0; if(target == 1) return 1; int a = 1; int b = 2; while(target&gt;1)&#123; b = a + b; a = b - a; target --; &#125; return a; &#125;&#125; 这道题还有扩展，如下 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 注意和上题的区别。 到达1级台阶只有1种可能，到达2级台阶有2种可能；可记为f(1) = 1,f(2) = 2。要到达3级台阶，可以选择在1级台阶处起跳，也可以选择在2级台阶处起跳，也可直接跳到3级，所以只需求到达1级台阶的可能情况 + 到达2级台阶的可能情况 + 1，即f(3) = f(2) +f(1) + 1同理到达n级台阶，可以在n-1级台阶起跳，可在n-2、n-1、n-3…级台阶起跳，f(n) = f(n-1)+f(n-2)+f(n-3)…+1,如果令f(n-n) = f(0) = 1,上式可表示为f(n) = f(n-1)+f(n-2)+f(n-3)…+f(n-n)，有了通项公式找出规律也不是难事了，不过还有种更好理解的思路：前n-1级台阶，每级台阶都有两种选择——跳到此或不跳到此，对于最后一级n级，没得选择，必须跳到这里，所以总共有有2^(n-1)种跳法。 矩形覆盖问题 我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 这个问题本质还是斐波那契数列… 覆盖2*n的矩形的方法记为f(n)。 当最后一步是竖着放时候，说明前一步已经覆盖了2*(n-1)，记为f(n - 1) 当最后一步是横着放的时候，倒数第二次也必然是横着放的。这个状态已经覆盖了2* (n-2)，记为f(n - 2) 因为最后一步只有横竖放两种可能，所以将上述两种方法可能性加起来即可。 覆盖2*1的矩形只有1种方法，覆盖2*2的矩形有横竖2种方法。于是f(1) = 1, f(2) = 2 这和能跳1级也能跳2级的青蛙是一样的。代码直接copy过来就行！]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer面试题9--两个栈实现队列]]></title>
    <url>%2F2019%2F09%2F17%2F%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%989-%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[剑指offer面试题9–两个栈实现队列 用两个栈来实现一个队列，完成队列的push和pop操作。队列中的元素为int类型。 刚开始两个栈都是空的，要进队列，可以将元素压入任何一个栈，不妨就压入stack1中，我们知道元素在栈中是后进先出的，因此要出列需要删除stack1最底部的元素，此时stack2派上用场了，将stack1的元素再压入stack2中，现在元素的排列变成了原来插入的顺序，要出列的元素到了栈顶，要完成出列操作就很方便了。若要继续出列，只要stack2不为空，只需继续从stack2中出栈即可，因为stack2中的栈顶元素就是最先入列的元素。若stack2为空，就将stack1中的元素压入到stack2后，再弹出栈顶元素。如果要入列，就直接压入stack1中。 总结一下就是： stack1专门用于进入队列 stack2专门用于出队列 出列操作。stack2不为空就直接出列；为空就将stack1中所有元素压入stack2中，再弹出栈顶元素。 123456789101112131415161718192021public class TwoStackImpQueue&#123; private LinkedList&lt;Integer&gt; stack1 = new LinkedList&lt;&gt;(); private LinkedList&lt;Integer&gt; stack2 = new LinkedList&lt;&gt;(); public void enqueue(int node)&#123; // stack1专门用于进入队列 stack1.push(node); &#125; public int dequeue()&#123; if(stack1.isEmpty() &amp;&amp;stack2.isEmpty())&#123; throw new RuntimeException("队列为空"); &#125; if(stack2.isEmpty())&#123; while(!stack1.isEmpty())&#123; stack2.push(stack1.pop()); &#125; &#125; return stack2.pop(); &#125;&#125; 相关题目–两个队列实现栈刚开始两个队列都为空，进栈时，可以进入任意一个队列。不妨默认进入Queue a。后续进栈时操作，哪个队列不为空（将看到，另外一个队列肯定为空）就进入该队列中。出栈操作，最后进入队列的要先出栈，而此时要出栈的元素在队列最后，但是队列只支持在队列头删除，因此将除了最后一个元素之外的所有元素都删除并复制一份到另一个队列Queue another，然后出列最后一个元素即可。此时Queue a成了空队列。之后每次出列操作都像上述以样：将不为空的队列中除最后一个元素的其余元素删除并复制到另一个空队列中，再删除原队列中唯一一个元素并弹出。每次出栈操作后，总有一个队列是空的。又因为进栈时也是进入不为空的那个队列，因此进出栈操作时总有一个队列是空的。 这两个队列不像上面的例子中有明确的分工，在两个队列实现栈的例子中，它们交替实现进栈或出栈的功能。 总结一下： 进栈，进入不为空的那个队列中 出栈，将不为空队列中除倒数最后一个元素外的其余元素移动到另一个空队列中，紧接着弹出原队列的最后一个元素。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.util.LinkedList;import java.util.Queue;/** * 两个队列实现一个栈 */public class TwoQueueImpStack &#123; private Queue&lt;Integer&gt; a; private Queue&lt;Integer&gt; another; public TwoQueueImpStack() &#123; this.a = new LinkedList&lt;&gt;(); this.another = new LinkedList&lt;&gt;(); &#125; public void push(int node) &#123; if (a.isEmpty() &amp;&amp; another.isEmpty()) &#123; a.offer(node); &#125; else if (!a.isEmpty())&#123; a.offer(node); &#125; else &#123; another.offer(node); &#125; &#125; public int pop() &#123; if (a.isEmpty() &amp;&amp; another.isEmpty()) &#123; throw new RuntimeException("栈已空"); &#125; if (!another.isEmpty()) &#123; int size = another.size(); // 除了最后一个元素，其他都删除并复制到另外一个队列中 for (int i = 0; i &lt; size - 1; i++) &#123; a.offer(another.poll()); &#125; return another.poll(); &#125; else &#123; int size = a.size(); for (int i = 0; i &lt; size -1; i++) &#123; another.offer(a.poll()); &#125; return a.poll(); &#125; &#125; public static void main(String[] args) &#123; TwoQueueImpStack a = new TwoQueueImpStack(); a.push(54); a.push(55); a.push(56); System.out.println(a.pop()); System.out.println(a.pop()); a.push(53); System.out.println(a.pop()); a.push(52); System.out.println(a.pop()); System.out.println(a.pop()); &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer面试题8--二叉树中序遍历的下一个节点]]></title>
    <url>%2F2019%2F09%2F17%2F%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%988-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[剑指offer面试题8–二叉树中序遍历的下一个结点 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 要找出中序遍历的下一个结点，要分几种情况探讨。 如果当前结点的右子结点不为空，那么下一个结点就是以该右子结点为根的子树的最左子结点；若该右子结点为根没有左子树，则下一个结点为该右子结点 如果当前结点的右子结点为空，看它的父结点。此时分两种情况，如果父结点的右子结点就是当前结点，说明这个结点在中序遍历中已经被访问过了，需要继续往上看其父结点…直到父结点的左子结点是当前结点为止，该父结点就是下一个结点。如果在一直往上的过程中已经到达根结点，而根结点的父结点为null，这种情况说明当前结点已经是中序序列的最后一个结点了，不存在下一个结点，应该返回null. 1234567891011121314151617181920212223242526272829303132public class InOrderNextNode&#123; private class TreeNode&#123; int val; TreeNode left = null; TreeNode right = null; TreeNode father = null; public TreeNode(int val)&#123; this.val = val; &#125; &#125; public TreeNode getNext(TreeNode cur)&#123; //当前节点的右子树不为空的情况 if(cur.right!=null)&#123; cur = cur.right; //右子树节点为根的左孩子不为空 while(cur.left!=null) cur = cur.left; return cur; &#125; //当前节点的右子树为空的情况 //当前节点是其父节点的右孩子，则将该节点指向其父节点 while(cur.father!=null &amp;&amp; cur.father.right == cur)&#123; cur = cur.father; &#125; //如果父节点的左孩子等于当前节点，则下一个节点为该父节点 //或者父节点为空，说明当前节点为根节点，返回空（也还是父节点） //cur.father == null || cur.father.left == cur return cur.father; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer面试题7--重建二叉树]]></title>
    <url>%2F2019%2F09%2F17%2F%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%987-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[剑指offer面试题7–重建二叉树 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 由中序遍历序列和前序或后序任一序列就能确定唯一的一棵二叉树，中序遍历序列是必须要的。 二叉树本来就是一种递归的结构，某个父结点，你可以说它拥有一个左子结点和一个右子结点，也可以说它拥有一棵以左子结点为根的左子树和一颗右子结点为根的右子树。因此二叉树的构建采用递归的方法是一种很自然的想法。 一棵树从上到下可以分解成了左子树、根结点、右子树，对于每一棵子树，又可以继续分解下去…一直到树底的叶子结点。相反，树的构建是从下到上的顺序，叶子结点可以看做最小的子树，这些子树的根结点成为其他结点的左右子结点，于是产生了更大的子树，这些子树继续成为上层结点的左右子结点….一直到根结点的做右子结点也确定下来。 关键是要找到每棵树的根结点，前序遍历的第一个结点就是树的根结点；在中序遍历里找到这个结点，其左边的结点都是根结点的左子树，其右边的结点都是根结点的右子树。假如根结点左边有M个结点，那么在前序序列中，根结点后的M个结点也是属于根结点的左子树的。前序序列中余下的后面的结点自然属于根结点的右子树。这样就可以把中序遍历的数组从根结点处分解成左右子树（对应的有两个子数组），然后递归地对这两个子数组执行同样的操作。现在重点是要在子数组中找到根结点——它依然是数组的第一个元素！ 比如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}。前序序列可知根结点是1，于是从中序序列可知，{4, 7, 2}属于根结点1的左子树，有3个结点；{5, 3 ,8, 6}属于根结点1的右子树。回到前序序列，除开第一个根结点，其后3个结点{2, 4, 7}就是左子树，余下的{3, 5, 6 ,8}是右子树。按照这些关系可以精确地将数组分解成两个子数组，递归地对两个数组进行同样的操作即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package Chap2;public class ReConstructTree &#123; private class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; public TreeNode reConstructBinaryTree(int[] pre, int[] in) &#123; TreeNode root = reConstructBinaryTree(pre, 0, pre.length - 1, in, 0, in.length - 1); return root; &#125; /** * 递归！ * [preStart + 1, preStart + i - inStart]是前序序列中左子树封闭区间 * [preStart + i - inStart + 1, preEnd]是前序序列中右子树封闭区间 * * [inStart, i - 1]是中序序列中左子树封闭区间 * [i + 1, inEnd]是中序序列中右子树封闭区间 * * @param pre 前序序列 * @param preStart 前序序列封闭区间的左指针 * @param preEnd 前序序列封闭区间的右指针 * @param in 中序序列 * @param inStart 中序序列封闭区间的左指针 * @param inEnd 中序序列封闭区间的右指针 * @return 树的根结点 */ private TreeNode reConstructBinaryTree(int[] pre, int preStart, int preEnd, int[] in, int inStart, int inEnd) &#123; // 还能分解成子数组就继续递归，不能分解（表现为end &gt; start）,就返回空子树给父结点 if (preStart &gt; preEnd || inStart &gt; inEnd) &#123; return null; &#125; int rootVal = pre[preStart]; TreeNode root = new TreeNode(rootVal); for (int i = inStart; i &lt;= inEnd; i++) &#123; if (in[i] == rootVal) &#123; root.left = reConstructBinaryTree(pre, preStart + 1, preStart + i - inStart, in, inStart, i - 1); root.right = reConstructBinaryTree(pre, preStart + i - inStart + 1, preEnd, in, i + 1, inEnd); &#125; &#125; return root; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer面试题6--从尾到头打印链表]]></title>
    <url>%2F2019%2F09%2F17%2F%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%986-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[剑指offer面试题6–从尾到头打印链表 输入一个链表的头节点，从尾到头打印链表每个节点的值。 使用栈我的做法：典型的后进先出，使用栈，顺序遍历一遍链表，依次将每个值入栈。得到的就是尾节点在前，头节点在后的列表。 123456789101112131415161718192021222324252627282930package Chap2;import java.util.LinkedList;import java.util.ArrayList;public class FromTail2Head &#123; // 节点类的定义 private class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125; &#125; /** * 更推荐使用栈，正序压入，尾节点就在最前面了 * * @param listNode 链表的头结点 * @return 从尾到头排列的结点 */ public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; LinkedList&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); for (ListNode node = listNode; node != null; node = node.next) &#123; stack.push(node.val); &#125; return new ArrayList&lt;&gt;(stack); &#125;&#125; 使用了“万能的”LinkedList，将其当栈使用。 使用递归递归的本质也是栈（系统创建的），下面采用递归的解法。 1234567891011121314/** * 利用递归，先递归到最后一个结点后开始依次返回。链表如果很长不适合用递归，递归深度将很大 */// 这是一个类成员变量private ArrayList&lt;Integer&gt; a = new ArrayList&lt;&gt;();public ArrayList&lt;Integer&gt; printListFromTailToHead2(ListNode listNode) &#123; if (listNode != null) &#123; printListFromTailToHead(listNode.next); a.add(listNode.val); &#125; return a;&#125; 可以看到如果没到链表尾部，就不断递归，直到最后一个节点，之后开始返回，执行下一句add方法，此时第一个被添加的是尾节点，最后一步递归调用的返回（即第一次递归调用）将添加最开始的头节点。因此得到的也是从尾到头的列表。 递归通常代码更简洁，但是如果链表很长时，递归调用的层级十分深，速度将大大降低。所以更推荐用第一种——栈的方法。]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer面试题5--替换空格]]></title>
    <url>%2F2019%2F09%2F17%2F%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%985-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[剑指offer面试题5–替换空格 请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 使用Java内置方法我的做法，由于使用Java语言，很容易想到使用库函数…遍历每个字符，如果遇到空格，就直接使用replace方法替换。 123456789101112131415161718/** * 遍历每一个字符，如果是空格就使用Java库函数replace替换 * * @param str 原字符串 * @return 替换空格后的字符串 */public String replaceSpace2(StringBuffer str) &#123; if (str == null) &#123; return null; &#125; for (int i = 0; i &lt; str.length(); i++) &#123; if (str.charAt(i) == ' ') &#123; str.replace(i, i + 1, "%20"); &#125; &#125; return str.toString();&#125; 当然如果你还知道String类有个方法叫replaceAll，那实现就更简洁了。 123456/** * 更加简洁的库函数方法 */public String replaceSpace3(StringBuffer str) &#123; return str.toString().replaceAll("\\s", "%20");&#125; 一行就完事儿，\\s是正则表达式，表示一个空格。 从后往前扫描本着学习的态度（而不是完成任务），上面的方法虽然简洁，但封装过好的方法掩藏了算法的实现细节。现在我们自己来实现一种比较底层的方法。 按照一般思维，总习惯从左往右处理字符串。当遇见第一个空格时，其后的所有字符都需要右移两个位置；当遇见第二个空格时，其后的字符又要右移…因此很多字符被移动了不止一次。能不能减少移动的次数呢？从前往后扫描要移动那么多次，不妨反过来从后往前扫描试试。 先遍历一遍原字符串，统计空格字符的个数。 由于要将空格（一个字符）变成%20（三个字符），所以需要将原字符串增长2 * 空格数 设置两个指针，一个指针oldP指向原字符串的末尾；另一个指针newP指向增长后的新字符串末尾。不断将oldP处的字符移动到newP处，然后两个指针都要左移；如果oldP处字符是空格，就在newP处设置三个字符：按顺序分别是0、2、%，同样的两个指针相应的左移。 按照上面的算法流程，写出如下代码。 12345678910111213141516171819202122232425262728293031323334353637383940package Chap2;public class ReplaceSpace &#123; /** * 库函数很方便，但是也要理解原理，所以掌握下面的方法是很有必要的。 * 1、统计空格数目 * 2、增长原字符串的长度 * 3、两个指针，一个指向原来字符串末尾，一个指向新字符串末尾。从后往前扫描字符串，并左移指针 */ public String replaceSpace(StringBuffer str) &#123; if (str == null) &#123; return null; &#125; // 统计空格个数 int spaceNum = 0; for (int i = 0;i &lt; str.length();i++) &#123; if (str.charAt(i) == ' ') &#123; spaceNum++; &#125; &#125; // 原来字符串的末尾指针 int oldP = str.length() - 1; // 设置新长度 str.setLength(str.length() + 2*spaceNum); // 新的字符串的末尾指针 int newP = str.length() - 1; while (oldP &gt;=0 &amp;&amp; newP &gt; oldP) &#123; if (str.charAt(oldP) == ' ') &#123; str.setCharAt(newP--, '0'); str.setCharAt(newP--, '2'); str.setCharAt(newP--, '%'); &#125; else &#123; str.setCharAt(newP--, str.charAt(oldP)); &#125; oldP--; &#125; return str.toString(); &#125;&#125; 每个字符最多只会被移动一次，所以时间复杂度为O(n)。 相关题目有两个有序的数组A1和A2，A1末尾有足够空间容纳A2。实现一个函数将A2的所有数字插入到A1中，并且所有数字是有序的。 因为空闲的空间在A1的末尾，所以从后往前比较两个A1和A2的数字，将更大的那个移动到A1的末尾，然后左移指针，继续比较两个数组中的数。当某个数组中的元素被取完了，就直接从另外一个数组取。 比如下面的例子 12A1 = [1, 2 ,4 ,7, 9, , , ...]A2 = [3, 5, 8, 10, 12] 假设A1的长度为10，现暂时只有5个元素，这个长度刚好能装下A2。从后往前比较A1和A2：12比9大，将12移动到A1[9]中，然后9和10继续比较，10移动到A1[8]中，9和8比较9移动到A1[7]中，如此这般直到扫描完两个数组，所有数字也都有序了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445 package Chap2;import java.util.Arrays;public class MergeTwoSortedArray &#123; public static void merge(Integer[] a, Integer[] b) &#123; // 统计a数组中有值元素的个数 int len = 0; for (int i = 0;i &lt; a.length;i++) &#123; if (a[i] != null) &#123; len++; &#125; &#125; int pA = len-1; // 指向a数组不为空的最后一个元素末尾 int pB = b.length-1; // 指向b数组不为空的最后一个元素末尾 int k = len + b.length -1; // 指向归并后数组不为空的最后一个元素末尾 while (k &gt;= 0) &#123; // a数组取完了，取b数组中的 if (pA &lt; 0) &#123; a[k--] = b[pB--]; // b数组取完了，取a数组中的 &#125; else if (pB &lt; 0) &#123; a[k--] = a[pA--]; // 否则谁的大取谁的值 &#125; else if (a[pA] &gt; b[pB]) &#123; a[k--]= a[pA--]; &#125; else &#123; a[k--] = b[pB--]; &#125; &#125; &#125; public static void main(String[] args) &#123; Integer[] a = new Integer[10]; Integer[] b= &#123;1, 3, 5, 7, 9&#125;; // &#123;2, 4, 6, 8, 10&#125; for (int i = 0; i &lt; 5; i++) &#123; a[i] = 2 * i + 2; &#125; merge(a, b); System.out.println(Arrays.toString(a)); &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer面试题4--二维数组中的查找]]></title>
    <url>%2F2019%2F09%2F17%2F%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%984-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[剑指offer面试题4–二维数组中的查找 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 根据题目，一个满足要求的二维数组长下面这样。 12341 2 8 92 4 9 124 7 10 136 8 11 15 对每一行进行二分查找我的做法：每一行的一维数组已经有序，所以使用二分查找在每一行中查找，一旦找到立即返回。对于一个M*N的二维数组，一次二分查找的时间复杂度为O(lg N), M行就是O(Mlg N)。根据上面的表述已经可以很轻松地写出代码了。 1234567891011121314151617181920212223242526272829303132package Chap2;public class FindIn2DArray &#123; /** * 我想到的做法，对每一行的一维数组作二分查找. * 如果矩阵是M*N的，一次二分查找是O(lg N), M行就是O(Mlg N) * * @param target 要查找的数 * @param array 二维数组 * @return true如果在数组中找到target */ public boolean Find2(int target, int[][] array) &#123; if (array != null &amp;&amp; array.length &gt; 0) &#123; for (int i = 0; i &lt; array.length; i++) &#123; int high = array[i].length - 1; int low = 0; while (low &lt;= high) &#123; int mid = low + (high - low) / 2; if (target &gt; array[i][mid]) &#123; low = mid + 1; &#125; else if (target &lt; array[i][mid]) &#123; high = mid - 1; &#125; else &#123; return true; &#125; &#125; &#125; return false; &#125; return false; &#125;&#125; 代码还可以优化，根据这个二维数组的特点，任意一个位置其右边的所有元素和下边的所有元素都是大于它的。所以当我们按照从上到下的顺序遍历每一行的一维数组时，如果某次有 12else if (target &lt; array[i][mid]) &#123;high = mid - 1;&#125; 那么以后的若干行，都不用再和mid之后的元素比较了。因为array[i][mid]处的元素和它下边、右边的值相比是最小的，这个最小的元素都大于target，下边的、右边的值不用比较也知道比target大。举个例子 12341 2 8 9 162 4 9 12 174 7 10 13 186 8 11 15 19 如果target是7，当在第一行中二分查找时候，target &lt; array[i][mid] = 8 ,high被更新为1， 既然7 &lt; 8，对于8的右边、下边所有元素都是大于7的，无需再比较。所以下次循环中数组应该缩小为 1232 44 76 8 最开始的想法中，每次循环都将high重新初始化。考虑上面的优化，我们当high的值被更新后，在后续的循环中不再重新被初始化即可。 1234567891011// 优化前for (int i = 0; i &lt; array.length; i++) &#123; int high = array[i].length - 1; int low = 0;&#125;// 优化后int high = array[0].length - 1;for (int i = 0; i &lt; array.length; i++) &#123; int low = 0;&#125; 由于是从上到下的顺序遍历每一行，所以优化操作不能用于low。（当然如果是从底向上遍历的顺序，只能优化low而不能优化high） 在右上角/左下角元素比较不断缩小范围上面二分查找对high的优化是个很好的启发，如果我们将target和矩阵中的某一个数比较，如果target &gt; arr[i][j]，那么array[i][j]的右边列所有元素、下边行的所有元素都有可能含有与target相等的数；同理如果target &lt; arr[i][j]，那么array[i][j]的左边列所有元素、上边行的所有元素都有可能含有与target相等的数。这样问题就复杂了，编写代码时可能无从下手（到底选择往哪个方向移动？），和矩阵的左上角、右下角也是一个道理。 我们来看右上角/左下角，由于这两个位置对称，现只看右上角。这个位置在一行中是最大的元素，在一列中是最小的元素。根据这个特点，当右上角的值大于target，右上角元素那一列都是大于target的，所以可以直接剔除这一列；当右上角的值小于target，右上角元素那一行都是小于target的，所以可以直接剔除这一行；当右上角的值等于target说明找到，立即返回。就这样不断将范围一行一列地缩小… 根据描述可写出如下代码 1234567891011121314151617181920212223242526public class FindIn2DArray &#123; /** * 更推荐的做法，由于矩阵从上到下递增，从左到右递增。 * 总是和二维矩阵的右上角元素比较（对称地，左下角也可以） * 如果目标比右上角的大，删除该行，行指针向下移动；如果比右上角的小，删除该列，列指针左移 */ public boolean Find(int target, int[][] array) &#123; if (array != null &amp;&amp; array.length &gt; 0) &#123; int N = array.length; // 总行数 int col = array[0].length - 1; // 列索引 int row = 0; // 行索引 // array[row][col]是右上角的元素 while (row &lt; N &amp;&amp; col &gt;= 0) &#123; if (target &lt; array[row][col]) &#123; col--; &#125; else if (target &gt; array[row][col]) &#123; row++; &#125; else &#123; return true; &#125; &#125; return false; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer面试题3--数组中的重复数字]]></title>
    <url>%2F2019%2F09%2F17%2F%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%983-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[剑指offer面试题3–数组中的重复数字 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2或者3。 排序后相邻元素两两比较我想到的方法是：先对数组排序，如果有重复元素排序后将会相邻。然后相邻元素两两比较，有相等的情况就找到了重复数字。排序一个长度为n的数组时间复杂度为O(nlg n)。 代码如下 1234567891011121314public boolean duplicate2(int numbers[],int length,int [] duplication) &#123; if (numbers == null || length == 0)&#123; return false; &#125; Arrays.sort(numbers); for (int i = 0;i &lt; length - 1;i++) &#123; if (numbers[i] == numbers[i + 1]) &#123; duplication[0] = numbers[i]; return true; &#125; &#125; return false;&#125; 利用题干信息——长度为n的数组里的所有数字都在0到n-1的范围内上面的实现对于任意数组都是通用的。我们要善于抓住题干的已知信息，比如题目中明确说明了长度为n的数组里面的数字全是[0, n-1]之间的。从这句话能获得什么信息呢？如果将数组排好序，那么数组每一个位置都有numbers[i] = i，如果有重复元素，说明[0, n-1]中某些数字空缺了，某些数字有多个。那么必然有某个j !=i的numbers[j] == numbers[i]，如果找到满足上述条件的数字，就找到了重复数字。 如果值i没有在正确的位置（满足numbers[i] == i），通过交换两个元素，将值i放到正确的位置。这个过程可以看成是排序。 当numbers[i] != i，若令numbers[i] = j，显然j != i；如果此时numbers[j] == numbers[i]说明在与i不同的位置j找到重复元素。否则重复上一步。 1234567891011121314151617181920212223242526272829303132333435363738394041424344package Chap2;import java.util.Arrays;public class FindDuplicate &#123; /** * 推荐的做法，通过交换元素，将值i保存到numbers[i] * 在numbers[i]不和i相等时，如果numbers[i]和numbers[numbers[i]]相等就说明重复元素； * 否则就交换这两个元素，这个过程相当于排序。举个例子，通过交换将2放入numbers[2]。 * @param numbers 待查找的数组 * @param length 数组的长度，其实就是numbers.length * @param duplication 用于保存重复数字，第一个被找到的重复数字存放在duplication[0]中 * @return 如果在数组中有重复元素 */ public boolean duplicate(int numbers[],int length,int [] duplication) &#123; if (numbers == null || length &lt;= 0) &#123; return false; &#125; for (int i = 0;i &lt; length;i++)&#123; if (numbers[i] &lt; 0 || numbers[i] &gt; length -1) &#123; return false; &#125; &#125; for (int i = 0; i&lt; length; i++) &#123; while (numbers[i] != i) &#123; // 现在numbers[i] != i ，设numbers[i] = j,所以如果下面的if成立,就是numbers[i] == numbers[j],说明找到 重复 if (numbers[i] == numbers[numbers[i]]) &#123; duplication[0] = numbers[i]; return true; &#125; swap(numbers, i, numbers[i]); &#125; &#125; return false; &#125; // 交换numbers[i]和numbers[numbers[i]] private void swap(int[] numbers, int p, int q) &#123; int temp = numbers[p]; numbers[p] = numbers[q]; numbers[q] = temp; &#125;&#125; 代码中尽管有一个两重循环，但是每个数字只需交换一两次就能被放在正确的位置上，因此总的时间复杂度为O(n)。而且所有操作都在原数组上进行，没有引入额外的空间，空间复杂度为O(1)。]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer面试题2--单例模式]]></title>
    <url>%2F2019%2F09%2F17%2F%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%982-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[剑指offer面试题2–单例模式单例模式规则 构造函数私有化（private），使得不能直接通过new的方式创建实例对象； 通过new在代码内部创建一个（唯一）的实例对象； 定义一个public static的公有静态方法，返回上一步中创建的实例对象；由于在静态方法中，所以上一步的对象也应该是static的。 根据这个规则，我们可以写出如下模式，这种模式又被称为饿汉模式。不管用不用得到，先new出来再说。 饿汉模式12345678910111213141516171819package Chap2;/** * 单例模式，饿汉模式，不管为不为空，先直接new一个出来 */public class SingletonImp &#123; // 饿汉模式 private static SingletonImp singletonImp = new SingletonImp(); // 私有化（private）该类的构造函数 private SingletonImp() &#123; &#125; public static SingletonImp getInstance() &#123; return singletonImp; &#125; public static void main(String[] args) &#123; System.out.println(SingletonImp.getInstance()); &#125;&#125; 和饿汉模式对应的称为懒汉模式，实例为空时才new出来。 懒汉式123456789101112131415161718192021package Chap2;/** * 单例模式，懒汉模式，为空才new */public class SingletonImp2 &#123; private static SingletonImp2 singletonImp2; private SingletonImp2() &#123;&#125; // 懒汉模式 public static SingletonImp2 getInstance() &#123; if (singletonImp2 == null) &#123; singletonImp2 = new SingletonImp2(); &#125; return singletonImp2; &#125; public static void main(String[] args) &#123; System.out.println(SingletonImp2.getInstance()); &#125;&#125; 以上代码有很多待改进的地方。下面一步步来优化。 能在多线程下工作，但效率不高懒汉模式在单线程下可以很好地工作，但是如果多个线程同时执行到if (singletonImp2 == null)这句判空操作，那么将会同时创建多个实例对象，所以为了保证在多线程下实例只被创建一次，需要加同步锁。 123456789101112131415161718192021package Chap2;/** * SingletonImp2在多线程中，如果多个线程同时运行到if (singletonImp2 == null) 就会创建多个对象 * 所以加上同步锁 */public class SingletonImp3 &#123; private static SingletonImp3 singletonImp3; private SingletonImp3() &#123;&#125; // 懒汉模式 public static SingletonImp3 getInstance() &#123; // 同步锁的加入 synchronized (SingletonImp3.class) &#123; if (singletonImp3 == null) &#123; singletonImp3 = new SingletonImp3(); &#125; &#125; return singletonImp3; &#125;&#125; 同步锁只在实例第一次被创建时候才加上上面的代码在每次调用方法时候都会加锁（即使实例早已被创建），我们知道加锁是很耗时的，实际上我们主要是为了保证在对象为null时，只new出一个实例，只在这个时候加锁就够了。基于这点，改进如下 123456789101112131415161718192021222324package Chap2;/** * SingletonImp3中每次调用getInstance都会加同步锁，而加锁是一个很耗时的过程 * 实际上加锁只需要在第一次创建对象时 */public class SingletonImp4 &#123; private static SingletonImp4 singletonImp4; private SingletonImp4() &#123;&#125; public static SingletonImp4 getInstance() &#123; // 第一次创建时才加锁 if (singletonImp4 == null) &#123; synchronized (SingletonImp4.class) &#123; if (singletonImp4 == null) &#123; singletonImp4 = new SingletonImp4(); &#125; &#125; &#125; return singletonImp4; &#125;&#125; 利用静态代码块我们知道在Java中，静态代码块只会在用到该类的时候（类加载，调用了静态方法等）被调用唯一的一次，因此在静态代码块中创建实例对象是个不错的选择。 12345678910111213141516171819202122232425262728package Chap2;/** * 静态代码块只在类加载的时候调用一次（静态方法调用等第一次用到该类的时候） */public class SingletonImp5 &#123; private static SingletonImp5 singletonImp5; private SingletonImp5() &#123;&#125; static &#123; singletonImp5 = new SingletonImp5(); &#125; public static SingletonImp5 getInstance() &#123; return singletonImp5; &#125; public static void func() &#123; &#125; public static void main(String[] args) &#123; // 调用任意静态方法，都会创建实例，导致过早创建 SingletonImp5.func(); System.out.println(SingletonImp5.singletonImp5); &#125;&#125; 使用静态代码块，按需创建实例上面的实现种，如果有其他的静态方法（比如上面的func()），我们调用它就会导致静态代码块被执行，实例也随之创建，但此时我们可能并不需要这个实例对象——这就导致了该实例被过早地创建了。我们想要的效果是：只有调用getInstance静态方法时，实例才被创建，调用其他静态方法或者其他任何时候都不会创建实例对象，即按照我们的需求在合适的时间被创建。 123456789101112131415161718192021222324252627282930package Chap2;/** * SingletonImp5使用静态代码块，如果该类中还有其他静态方法，调用后就会执行静态代码块使得对象过早创建 * 使用一个静态类来创建Singleton，其他静态方法只要没有调用Nested.singletonImp6就不会创建Singleton * 实现了需要时才创建实例对象，避免过早创建 */public class SingletonImp6 &#123; private SingletonImp6() &#123;&#125; // 专门用于创建Singleton的静态类 private static class Nested &#123; private static SingletonImp6 singletonImp6; static &#123; singletonImp6 = new SingletonImp6(); &#125; &#125; public static SingletonImp6 getInstance() &#123; return Nested.singletonImp6; &#125; public static void func() &#123; &#125; public static void main(String[] args) &#123; System.out.println(SingletonImp6.getInstance()); &#125;&#125; 可以看到，我们专门建立了一个静态类用于创建这个实例，任何静态方法只要没有用到Nested就不会创建实例对象。只在getInstance方法中才调用Nested.singletonImp6保证了当我们调用SingletonImp的其他静态方法时，实例不会创建。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java_排序]]></title>
    <url>%2F2019%2F09%2F08%2Fjava%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序思路 比较相邻的元素，如果第一个比第二个大，就交换它们两个。 对每一对相邻元素做同样的工作，从第一对到最后一对，这样2在最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个元素。 重复步骤1—3,直到排序完成。 java代码具体实现12345678910111213public class BubbleSort&#123; public static void sort(int[] arr)&#123; for(int i = 0;i&lt;arr.length-1;i++)&#123; for(int j = 0;j&lt;arr.length-1-i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; &#125;&#125; 选择排序思路把第一个元素依次和后面的所有元素进行比较。第一次结束后，就会有最小值出现在最前面。 java代码具体实现12345678910111213public class SelectionSort&#123; public static void sort(int[] arr)&#123; for(int i = 0;i&lt;arr.length-1;i++)&#123; for(int j = i+1;j&lt;arr.length;j++)&#123; if(arr[j]&lt;arr[i])&#123; int temp = arr[j]; arr[j] = arr[i]; arr[i] = temp; &#125; &#125; &#125; &#125;&#125; 插入排序思路1234567891011将n个元素的数列分为已有序和无序两个部分，如插入排序过程示例下所示： &#123;&#123;a1&#125;，&#123;a2，a3，a4，…，an&#125;&#125; &#123;&#123;a1⑴，a2⑴&#125;，&#123;a3⑴，a4⑴ …，an⑴&#125;&#125; &#123;&#123;a1(n-1），a2(n-1) ，…&#125;,&#123;an(n-1)&#125;&#125; 每次处理就是将无序数列的第一个元素与有序数列的元素从后往前逐个进行比较，找出插入位置，将该元素插入到有序数列的合适位置中。 java具体代码实现1234567891011public class InsertSort&#123; public static void sort(int[] arr)&#123; for(int i = 1;i&lt;arr.length;i++)&#123; for(int j = i;(j&gt;=1)&amp;&amp;(arr[j]&lt;arr[j-1]);j--)&#123; int temp = arr[j]; arr[j] = arr[j-1]; arr[j-1] = temp; &#125; &#125; &#125;&#125; 希尔排序思路 先取一个小于n的整数d1作为第一个增量 把文件的全部记录分为（n除以d1）个组。所有距离为dl的倍数的记录放在同一个组中 先在各组内进行直接插入排序，然后，取第二个增量d2&lt;d1，重复上述的分组和排序 直至所取的增量dt = 1，即所有记录放在同一组中进行直接插入排序即可。 java具体代码实现1234567891011121314151617181920public class ShellSort&#123; public static void sort(int[] arr)&#123; for(int i = arr.length/2;i&gt;2;i/=2)&#123; for(int j = 0;j&lt;i;j++)&#123; insertSort(arr,j,i); &#125; &#125; insertSort(arr,0,1); &#125; private static void insertSort(int[] arr,int start;int inc)&#123; for(int i = start+inc;i&lt;arr.length;i+=inc)&#123; for(int j = i;(j&gt;=inc)&amp;&amp;(arr[j]&lt;arr[j-inc]);j-=inc)&#123; int temp = arr[j]; arr[j] = arr[j-inc]; arr[j-inc] = temp; &#125; &#125; &#125;&#125; 快速排序思路一趟快速排序的算法如下： 设置两个变量i、j，排序开始的时候：i=0，j=N-1； 以第一个数组元素作为关键数据，赋值给key，即 key=A[0]； 从j开始向前搜索，即由后开始向前搜索（j=j-1即j–），找到第一个小于key的值A[j]，A[i]与A[j]交换； 从i开始向后搜索，即由前开始向后搜索（i=i+1即i++），找到第一个大于key的A[i]，A[i]与A[j]交换； 重复第3、4、5步，直到 i=j； ==3,4步是在程序中没找到时候j=j-1，i=i+1，直至找到为止。找到并交换的时候i， j指针位置不变。另外当i=j这过程一定正好是i+或j-完成的最后令循环结束== java具体代码实现12345678910111213141516171819202122232425262728293031public class QuickSort&#123; public static void sort(int[] arr)&#123; quickSort(arr,0,arr.length-1); &#125; private static void quickSort(int[] arr,int low,int high)&#123; int i = low; int j = high; int temp = arr[i]; while(i &lt; j)&#123; while(i &lt; j &amp;&amp; temp &lt; arr[j])&#123; j--; &#125; if(i&lt;j)&#123; arr[i] = arr[j]; i++; &#125; while(i&lt;j &amp;&amp; temp &gt; arr[i])&#123; i++; &#125; if(i &lt; j)&#123; arr[j] = arr[i]; &#125; &#125; arr[i] = temp; if(low&lt;i) quickSort(arr,low,i-1); if(i&lt;high) quickSort(arr,j+1,high); &#125;&#125; 堆排序思路堆排序利用了大根堆（或小根堆）堆顶记录的关键字最大（或最小）这一特征， 使得在当前无序区中选取最大（或最小）关键字的记录变得简单。 java具体代码实现123456789101112131415161718192021222324252627282930313233343536public class HeapSort&#123; public static sort(int[] arr)&#123; initMaxHeap(arr,arr.length); for(int i = arr.length-1;i&gt;0;i--)&#123; int temp = arr[0]; arr[] = arr[i]; arr[i] = temp; createMaxHeap(arr,i,0); &#125; &#125; // 初始化创建最大堆 //从第1个非叶子节点a[h]开始到a[0]为止调用createMaxHeap函数的过程 private void initMaxHeap(int[] arr,int n)&#123; for(int i = (n-2)/2;i&gt;=0;i--) createMaxHeap(arr,n,i); &#125; //调整长度为n的数组arr，使非叶子节点a[h]为根的二叉树满足最大堆 private static void createMaxHeap(int[] arr,int n,int h)&#123; int i = h; int j = 2*i+1; int temp = arr[i]; boolean flag = false; while(j&lt;n&amp;&amp;!flag)&#123; if(j+1&lt;n &amp;&amp; arr[j]&lt;arr[j+1]) j++; if(temp&gt;arr[j]) flag = true; else&#123; arr[i] = arr[j]; i = j; j = 2*i+1; &#125; &#125; arr[i] = temp; &#125;&#125; 归并排序定义归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 算法描述 把长度为n的输入序列分成两个长度为n/2的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。 java代码具体实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MergeSort&#123; public static void sort(int[] arr)&#123; //先创建一个临时数组，是为了避免在递归的过程中频繁开辟空间 int[] temp = new int[arr.length]; mergeSort(arr,0,arr.length-1,temp); &#125; private static void mergeSort(int[] arr,int[] temp,int left,int right)&#123; if(left&lt;right)&#123; int mid = (left+right)/2; //对左边子序列进行归并排序，使之有序 mergeSort(arr,temp,left,mid); //对右边子序列进行归并排序，使之有序 mergeSort(arr,temp,mid+1,right); //对左右两个有序子序列进行合并 merge(arr,temp,left,mid,right); &#125; &#125; private static void merge(int[] arr,int[] temp,int left,int mid,int right)&#123; int i = left; //左边子序列的指针 int j = mid+1; //右边子序列的指针 int t = 0; //临时数组指针 while(i&lt;=mid &amp;&amp; j&lt;= right)&#123; if(arr[i]&lt;=arr[j])&#123; temp[t++]=arr[i++]; &#125; else&#123; temp[t++]=arr[j++]; &#125; &#125; //情况1：若当右子序列已全部填充进临时数组，将左子序列填充进临时数组 while (i &lt;= mid) &#123; temp[t++] = arr[i++]; &#125; //情况2：若当左子序列已全部填充进临时数组，将右子序列填充进临时数组 while (j&lt;=right) &#123; temp[t++] = arr[j++]; &#125; //将临时数组指针初始化为0 t = 0; while(left&lt;=right)&#123; arr[left++] = temp[t++]; &#125; &#125;&#125; 计数排序计数排序适用的数据范围计数排序需要占用大量空间，它仅适用于数据比较集中的情况。比如 [0100]，[1000019999] 这样的数据。 计数排序、基数排序、桶排序则属于非比较排序。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。 非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。 过程分析计数排序的基本思想是：对每一个输入的元素arr[i]，确定小于 arr[i] 的元素个数。所以可以直接把 arr[i] 放到它输出数组中的位置上。假设有5个数小于 arr[i]，所以 arr[i] 应该放在数组的第6个位置上。 需要三个数组： 待排序数组 int[] arr = new int[]{4,3,6,3,5,1}; 辅助计数数组 int[] help = new int[max - min + 1]; //该数组大小为待排序数组中的最大值减最小值+1 输出数组 int[] res = new int[arr.length]; 求出待排序数组的最大值max=6， 最小值min=1 实例化辅助计数数组help，help用来记录每个元素之前出现的元素个数 计算 arr 每个数字应该在排序后数组中应该处于的位置，此时 help = [1,1,4,5,6,7]; 根据 help 数组求得排序后的数组，此时 res = [1,3,3,4,5,6] java具体代码实现123456789101112131415161718192021222324252627282930313233public class CountSort&#123; public static void sort(int[] arr)&#123; int max = Integer.MIN_VALUE; int min = Integer.MAX_VALUE; //找出数组中的最大值和最小值 for(int i = 0;i&lt;arr.length;i++)&#123; max = Math.max(max,arr[i]); min = Math.min(min,arr[i]); &#125; // int[] help = new int[max-min+1]; //找出每个数字出现的次数 for(int i = 0;i&lt;arr.length;i++)&#123; int mapPos = arr[i]-min; help[mapPos]++; &#125; //计算每个数字应该在排序后数组中应该处于的位置 for(int i = 1;i&lt;help.length;i++)&#123; help[i] = help[i-1]+help[i]; &#125; //根据help数组进行排序 int res[] = new int[arr.length]; for(int i = 0;i&lt;arr.length;i++)&#123; int pos = --help[arr[i]-min]; res[pos] = arr[i]; &#125; arr = res; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[队列]]></title>
    <url>%2F2019%2F09%2F08%2F%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[队列什么是队列队列也是一种线性结构。相比数组，队列对应的操作是数组的子集。只能从一端（队尾）添加元素，只能从另一端（队头）取出元素。是一种先进先出的数据结构。 队列底层的实现队列底层的实现可以是动态数组和链表。 队列常见的一些方法12345678public interface Queue&lt;E&gt; &#123; int getSize(); boolean isEmpty(); void enqueue(E e); E dequeue(); E getFront();&#125; 动态数组实现的队列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class ArrayQueue&lt;E&gt; implements Queue&lt;E&gt; &#123; //Array代码可以观看我之前写过的动态数组代码或者可以用java的集合类ArrayList private Array&lt;E&gt; array; public ArrayQueue(int capacity)&#123; array = new Array&lt;&gt;(capacity); &#125; public ArrayQueue()&#123; array = new Array&lt;&gt;(); &#125; @Override public int getSize()&#123; return array.getSize(); &#125; @Override public boolean isEmpty()&#123; return array.isEmpty(); &#125; public int getCapacity()&#123; return array.getCapacity(); &#125; @Override public void enqueue(E e)&#123; array.addLast(e); &#125; @Override public E dequeue()&#123; return array.removeFirst(); &#125; @Override public E getFront()&#123; return array.getFirst(); &#125; @Override public String toString()&#123; StringBuilder res = new StringBuilder(); res.append("Queue: "); res.append("front ["); for(int i = 0 ; i &lt; array.getSize() ; i ++)&#123; res.append(array.get(i)); if(i != array.getSize() - 1) res.append(", "); &#125; res.append("] tail"); return res.toString(); &#125; 动态数组实现的队列时间复杂度分析：除了出队时间复杂度是O(n)，其他操作是O(1) 链表实现的队列1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class LinkedListQueue&lt;E&gt; implements Queue&lt;E&gt; &#123; private class Node&#123; public E e; public Node next; public Node(E e, Node next)&#123; this.e = e; this.next = next; &#125; public Node(E e)&#123; this(e, null); &#125; public Node()&#123; this(null, null); &#125; @Override public String toString()&#123; return e.toString(); &#125; &#125; private Node head, tail; private int size; public LinkedListQueue()&#123; head = null; tail = null; size = 0; &#125; @Override public int getSize()&#123; return size; &#125; @Override public boolean isEmpty()&#123; return size == 0; &#125; @Override public void enqueue(E e)&#123; if(tail == null)&#123; tail = new Node(e); head = tail; &#125; else&#123; tail.next = new Node(e); tail = tail.next; &#125; size ++; &#125; @Override public E dequeue()&#123; if(isEmpty()) throw new IllegalArgumentException("Cannot dequeue from an empty queue."); Node retNode = head; head = head.next; retNode.next = null; if(head == null) tail = null; size --; return retNode.e; &#125; @Override public E getFront()&#123; if(isEmpty()) throw new IllegalArgumentException("Queue is empty."); return head.e; &#125; @Override public String toString()&#123; StringBuilder res = new StringBuilder(); res.append("Queue: front "); Node cur = head; while(cur != null) &#123; res.append(cur + "-&gt;"); cur = cur.next; &#125; res.append("NULL tail"); return res.toString(); &#125;&#125; 用上述链表的形式实现的队列的方法时间复杂度都为O(1)。原因是添加了一个指向链表尾部的指针，用来解决入队的时间复杂度，把原为O(n)变为O(1)。 循环队列用来解决动态数组实现的队列出队的时间复杂度问题。 两个判断条件要弄清楚： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class LoopQueue&lt;E&gt; implements Queue&lt;E&gt; &#123; private E[] data; private int front, tail; private int size; public LoopQueue(int capacity)&#123; data = (E[])new Object[capacity + 1]; front = 0; tail = 0; size = 0; &#125; public LoopQueue()&#123; this(10); &#125; public int getCapacity()&#123; return data.length - 1; &#125; @Override public boolean isEmpty()&#123; return front == tail; &#125; @Override public int getSize()&#123; return size; &#125; @Override public void enqueue(E e)&#123; if((tail + 1) % data.length == front) resize(getCapacity() * 2); data[tail] = e; tail = (tail + 1) % data.length; size ++; &#125; @Override public E dequeue()&#123; if(isEmpty()) throw new IllegalArgumentException("Cannot dequeue from an empty queue."); E ret = data[front]; data[front] = null; front = (front + 1) % data.length; size --; if(size == getCapacity() / 4 &amp;&amp; getCapacity() / 2 != 0) resize(getCapacity() / 2); return ret; &#125; @Override public E getFront()&#123; if(isEmpty()) throw new IllegalArgumentException("Queue is empty."); return data[front]; &#125; private void resize(int newCapacity)&#123; E[] newData = (E[])new Object[newCapacity + 1]; for(int i = 0 ; i &lt; size ; i ++) newData[i] = data[(i + front) % data.length]; data = newData; front = 0; tail = size; &#125; @Override public String toString()&#123; StringBuilder res = new StringBuilder(); res.append(String.format("Queue: size = %d , capacity = %d\n", size, getCapacity())); res.append("front ["); for(int i = front ; i != tail ; i = (i + 1) % data.length)&#123; res.append(data[i]); if((i + 1) % data.length != tail) res.append(", "); &#125; res.append("] tail"); return res.toString(); &#125;&#125; 循环队列的时间复杂度分析：采用均摊复杂度，我们可以发现出队和入队的时间复杂度都为O(1)。所以循环队列的相关操作的时间复杂度都为O(1)。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈]]></title>
    <url>%2F2019%2F09%2F08%2F%E6%A0%88%2F</url>
    <content type="text"><![CDATA[栈什么是栈栈是一种特殊的线性表，仅允许在表的一端进行插入和删除运算。这一端被称为栈顶（top），相对地，把另一端称为栈底（bottom）。向一个栈插入新元素又称作进栈、入栈或压栈（push），它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈（pop），它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。所以栈具有“后入先出”的特点（LIFO）。 栈底层的实现栈的底层实现可以是动态数组和链表 栈常见的一些方法12345678public interface Stack&lt;E&gt; &#123; int getSize(); boolean isEmpty(); void push(E e); E pop(); E peek();&#125; 动态数组实现的栈12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class ArrayStack&lt;E&gt; implements Stack&lt;E&gt; &#123; private Array&lt;E&gt; array; public ArrayStack(int capacity)&#123; array = new Array&lt;&gt;(capacity); &#125; public ArrayStack()&#123; array = new Array&lt;&gt;(); &#125; @Override public int getSize()&#123; return array.getSize(); &#125; @Override public boolean isEmpty()&#123; return array.isEmpty(); &#125; public int getCapacity()&#123; return array.getCapacity(); &#125; @Override public void push(E e)&#123; array.addLast(e); &#125; @Override public E pop()&#123; return array.removeLast(); &#125; @Override public E peek()&#123; return array.getLast(); &#125; @Override public String toString()&#123; StringBuilder res = new StringBuilder(); res.append("Stack: "); res.append('['); for(int i = 0 ; i &lt; array.getSize() ; i ++)&#123; res.append(array.get(i)); if(i != array.getSize() - 1) res.append(", "); &#125; res.append("] top"); return res.toString(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156//动态数组的实现public class Array&lt;E&gt; &#123; private E[] data; private int size; // 构造函数，传入数组的容量capacity构造Array public Array(int capacity)&#123; data = (E[])new Object[capacity]; size = 0; &#125; // 无参数的构造函数，默认数组的容量capacity=10 public Array()&#123; this(10); &#125; // 获取数组的容量 public int getCapacity()&#123; return data.length; &#125; // 获取数组中的元素个数 public int getSize()&#123; return size; &#125; // 返回数组是否为空 public boolean isEmpty()&#123; return size == 0; &#125; // 在index索引的位置插入一个新元素e public void add(int index, E e)&#123; if(index &lt; 0 || index &gt; size) throw new IllegalArgumentException("Add failed. Require index &gt;= 0 and index &lt;= size."); if(size == data.length) resize(2 * data.length); for(int i = size - 1; i &gt;= index ; i --) data[i + 1] = data[i]; data[index] = e; size ++; &#125; // 向所有元素后添加一个新元素 public void addLast(E e)&#123; add(size, e); &#125; // 在所有元素前添加一个新元素 public void addFirst(E e)&#123; add(0, e); &#125; // 获取index索引位置的元素 public E get(int index)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Get failed. Index is illegal."); return data[index]; &#125; public E getLast()&#123; return get(size - 1); &#125; public E getFirst()&#123; return get(0); &#125; // 修改index索引位置的元素为e public void set(int index, E e)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Set failed. Index is illegal."); data[index] = e; &#125; // 查找数组中是否有元素e public boolean contains(E e)&#123; for(int i = 0 ; i &lt; size ; i ++)&#123; if(data[i].equals(e)) return true; &#125; return false; &#125; // 查找数组中元素e所在的索引，如果不存在元素e，则返回-1 public int find(E e)&#123; for(int i = 0 ; i &lt; size ; i ++)&#123; if(data[i].equals(e)) return i; &#125; return -1; &#125; // 从数组中删除index位置的元素, 返回删除的元素 public E remove(int index)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Remove failed. Index is illegal."); E ret = data[index]; for(int i = index + 1 ; i &lt; size ; i ++) data[i - 1] = data[i]; size --; data[size] = null; // loitering objects != memory leak if(size == data.length / 4 &amp;&amp; data.length / 2 != 0) resize(data.length / 2); return ret; &#125; // 从数组中删除第一个元素, 返回删除的元素 public E removeFirst()&#123; return remove(0); &#125; // 从数组中删除最后一个元素, 返回删除的元素 public E removeLast()&#123; return remove(size - 1); &#125; // 从数组中删除元素e public void removeElement(E e)&#123; int index = find(e); if(index != -1) remove(index); &#125; @Override public String toString()&#123; StringBuilder res = new StringBuilder(); res.append(String.format("Array: size = %d , capacity = %d\n", size, data.length)); res.append('['); for(int i = 0 ; i &lt; size ; i ++)&#123; res.append(data[i]); if(i != size - 1) res.append(", "); &#125; res.append(']'); return res.toString(); &#125; // 将数组空间的容量变成newCapacity大小 private void resize(int newCapacity)&#123; E[] newData = (E[])new Object[newCapacity]; for(int i = 0 ; i &lt; size ; i ++) newData[i] = data[i]; data = newData; &#125;&#125; 栈应用的一些场景编辑器的撤销操作 系统调用栈 编译器的括号匹配 如下题： 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 12345678910111213141516171819202122232425262728293031class Solution &#123; public boolean isValid(String s) &#123; ArrayStack&lt;Character&gt; stack = new ArrayStack&lt;&gt;(); for(int i = 0 ; i &lt; s.length() ; i ++)&#123; char c = s.charAt(i); if(c == '(' || c == '[' || c == '&#123;') stack.push(c); else&#123; if(stack.isEmpty()) return false; char topChar = stack.pop(); if(c == ')' &amp;&amp; topChar != '(') return false; if(c == ']' &amp;&amp; topChar != '[') return false; if(c == '&#125;' &amp;&amp; topChar != '&#123;') return false; &#125; &#125; return stack.isEmpty(); &#125; public static void main(String[] args) &#123; System.out.println((new Solution()).isValid("()[]&#123;&#125;")); System.out.println((new Solution()).isValid("([)]")); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分搜索树]]></title>
    <url>%2F2019%2F09%2F08%2F%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[为什么要有树结构树结构本身是一种天然的组织结构。将数据使用数结构存储后，会很高效 二叉树特性： 二叉树和链表一样，是动态数据结构。 二叉树具有唯一根节点。每个节点最多有两个孩子，最多有一个父亲。 二叉树具有天然的递归结构。 满二叉树：在一棵二叉树中，如果所有分支节点都存在左子树和右子树，并且所有叶子节点都在同一层上。这样的二叉树称作满二叉树。 完全二叉树：如果一个具有n个节点的二叉树与满二叉树的前n个节点的结构相同，这样的二叉树被称为完全二叉树。 12345class Node&#123; E e; Node left;//左孩子 Node right;//右孩子&#125; 二分搜索树BST特性1）二分搜索树每个节点的值：大于左子树的所有节点的值；小于其右子树节点的值。 2）每一棵子树也是二分搜索树 3)）存储的元素必须有可比性 12345678910111213141516171819202122232425262728//实现Compareble接口是为了让存储的元素具有可比性public class BST&lt;E extends Comparable&lt;E&gt;&gt; &#123; //成员内部类 private class Node &#123; public E e; public Node left, right; public Node(E e) &#123;//Node类初始化 this.e = e; left = null; right = null; &#125; &#125; //成员变量 private Node root; //根节点 private int size; //元素个数 public BST()&#123; //BST初始化 root = null; size = 0; &#125; //返回元素个数 public int size()&#123; return size; &#125; //判断BST是否为空 public boolean isEmpty()&#123; return size == 0; &#125;&#125; 添加新元素代码讲解的是不包含重复元素和采用递归的写法。 如果想包含重复元素，只需定义左子树小于等于节点，或右子树大于等于节点。二分搜索树添加元素的非递归写法和链表很像。 思想：从根节点开始找插入的位置，满足二叉搜索树的特性，比左子节点大，比右子节点小。 步骤： 从根节点开始，先比较当前节点，如果当前节点为null那么很明显就应该插入到这个节点。 如果上面的节点不是null，那么和当前节点比较，如果小于节点就往左子树放，如果大于节点就往右子树放。 然后分别对左子树或者右子树递归的递归进行如上1、2步骤的操作。 123456789101112131415161718192021222324252627282930// 向二分搜索树中添加新的元素epublic void add(E e)&#123; if(root == null)&#123; root = new Node(e); size ++; &#125; else add(root, e);&#125;// 向以node为根的二分搜索树中插入元素e，递归算法private void add(Node node, E e)&#123; //求解最基本问题 if(e.equals(node.e)) return; else if(e.compareTo(node.e) &lt; 0 &amp;&amp; node.left == null)&#123; node.left = new Node(e); size ++; return; &#125; else if(e.compareTo(node.e) &gt; 0 &amp;&amp; node.right == null)&#123; node.right = new Node(e); size ++; return; &#125; //把原问题转化为更小的问题 if(e.compareTo(node.e) &lt; 0) add(node.left, e); else //e.compareTo(node.e) &gt; 0 add(node.right, e);&#125; 添加元素java代码改进版： 1234567891011121314151617181920// 向二分搜索树中添加新的元素epublic void add(E e)&#123; root = add(root, e);&#125;// 向以node为根的二分搜索树中插入元素e，递归算法// 返回插入新节点后二分搜索树的根private Node add(Node node, E e)&#123; //求解最基本问题 if(node == null)&#123; size ++; return new Node(e); &#125; //把原问题转化为更小的问题 if(e.compareTo(node.e) &lt; 0) node.left = add(node.left, e); else if(e.compareTo(node.e) &gt; 0) node.right = add(node.right, e); return node;&#125; 查询元素12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 看二分搜索树中是否包含元素epublic boolean contains(E e)&#123; return contains(root, e);&#125;// 看以node为根的二分搜索树中是否包含元素e, 递归算法private boolean contains(Node node, E e)&#123; //求解最基本问题 if(node == null) return false; //把原问题转化为更小的问题 if(e.compareTo(node.e) == 0) return true; else if(e.compareTo(node.e) &lt; 0) return contains(node.left, e); else // e.compareTo(node.e) &gt; 0 return contains(node.right, e);&#125;// 寻找二分搜索树的最小元素public E minimum()&#123; if(size == 0) throw new IllegalArgumentException("BST is empty!"); return minimum(root).e;&#125;// 返回以node为根的二分搜索树的最小值所在的节点private Node minimum(Node node)&#123; if(node.left == null) return node; return minimum(node.left);&#125;// 寻找二分搜索树的最大元素public E maximum()&#123; if(size == 0) throw new IllegalArgumentException("BST is empty"); return maximum(root).e;&#125;// 返回以node为根的二分搜索树的最大值所在的节点private Node maximum(Node node)&#123; if(node.right == null) return node; return maximum(node.right);&#125; 遍历遍历操作就是把所有节点都访问一遍(访问的原因和业务有关)，在线性结构下，遍历是极其简单的（for循环）。 树结构的遍历操作，两棵子树都要顾及。 前序遍历：若二叉树为空，则算法结束，否则：1）访问根节点。2）前序遍历根节点的左子树。3）前序遍历根节点的右子树。 1234567891011121314// 二分搜索树的前序遍历public void preOrder()&#123; preOrder(root);&#125;// 前序遍历以node为根的二分搜索树, 递归算法private void preOrder(Node node)&#123; if(node == null) return; System.out.println(node.e); preOrder(node.left); preOrder(node.right);&#125; 非递归的二叉树前序遍历算法 借助栈的数据结构来实现，步骤如下： 1）把根节点入栈 2）只要栈不为空，就依次把每个节点出栈 若该节点的右子树非空，将该右子树的根节点入栈 若该节点的左子树非空，将该左子树的根节点入栈 123456789101112131415// 二分搜索树的非递归前序遍历public void preOrderNR()&#123; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.isEmpty())&#123; Node cur = stack.pop(); System.out.println(cur.e); if(cur.right != null) stack.push(cur.right); if(cur.left != null) stack.push(cur.left); &#125;&#125; 中序遍历若二叉树为空，则算法结束，否则：1）中序遍历根节点的左子树。2）访问根节点。3）中序遍历根节点的右子树。 123456789101112// 二分搜索树的中序遍历public void inOrder()&#123; inOrder(root);&#125;// 中序遍历以node为根的二分搜索树, 递归算法private void inOrder(Node node)&#123; if(node == null) return; inOrder(node.left); System.out.println(node.e); inOrder(node.right);&#125; 后序遍历若二叉树为空，则算法结束，否则：1）后序遍历根节点的左子树。2）后序遍历根节点的右子树。3）访问根节点。 123456789101112// 二分搜索树的后序遍历public void postOrder()&#123; postOrder(root);&#125;// 后序遍历以node为根的二分搜索树, 递归算法private void postOrder(Node node)&#123; if(node == null) return; postOrder(node.left); postOrder(node.right); System.out.println(node.e);&#125; 层序遍历(广度优先遍历)利用队列的数据结构实现，步骤如下： 1）将根节点入队列 2）当队列不为空时，依次把队列中的节点出队列 若该节点的左子树不为空，将该左子树的根节点入队列 若该节点的右子树不为空，将该右子树的根节点入队列 123456789101112131415//二分搜索树的层序遍历public void leveOrder()&#123; if(root == null) return; Queue&lt;Node&gt; q = new LinkedList&lt;&gt;(); q.add(root); while(!q.isEmpty())&#123; Node cur = q.remove(); System.out.println(cur.e); if(cur.left!= null) q.add(cur.left); if(cur.right!=null) q.add(cur.right); &#125;&#125; 删除元素删除最小值所在节点思想：根据二分搜索树的特性，我们知道节点的左孩子小于该节点（依次递归，找到最小值) 12345678910111213141516171819202122// 从二分搜索树中删除最小值所在节点, 返回最小值public E removeMin()&#123; //寻找到二分搜索树中最小的元素 E ret = minimum(); root = removeMin(root); return ret;&#125;// 删除掉以node为根的二分搜索树中的最小节点// 返回删除节点后新的二分搜索树的根private Node removeMin(Node node)&#123; if(node.left == null)&#123; Node rightNode = node.right; node.right = null; size --; return rightNode; &#125; node.left = removeMin(node.left); return node;&#125; 删除最大值所在节点思想：根据二分搜索树的特性，我们知道节点的右孩子大于该节点（依次递归，找到最大值) 123456789101112131415161718192021// 从二分搜索树中删除最大值所在节点public E removeMax()&#123; E ret = maximum(); root = removeMax(root); return ret;&#125;// 删除掉以node为根的二分搜索树中的最大节点// 返回删除节点后新的二分搜索树的根private Node removeMax(Node node)&#123; if(node.right == null)&#123; Node leftNode = node.left; node.left = null; size --; return leftNode; &#125; node.right = removeMax(node.right); return node;&#125; 删除元素为e的节点分为三种情况 1）待删除元素的节点左子树为空 2）待删除元素的节点右子树为空 3）待删除元素的节点左右子树非空情况 1234567891011//第一种解法：找到待删除节点的后继节点来代替Node successor = minimum(node.right);successor.right = removeMin(node.right);successor.left = node.left;node.left = node.right = null;//第二种解法：找到待删除节点的前驱节点来代替Node precursor = maximum(node.left);precursor.left = removeMax(node.left);precursor.right = node.left;node.left = node.right = null; 具体java代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 从二分搜索树中删除元素为e的节点public void remove(E e)&#123; root = remove(root, e);&#125;// 删除掉以node为根的二分搜索树中值为e的节点, 递归算法// 返回删除节点后新的二分搜索树的根private Node remove(Node node, E e)&#123; if( node == null ) return null; if( e.compareTo(node.e) &lt; 0 )&#123; node.left = remove(node.left , e); return node; &#125; else if(e.compareTo(node.e) &gt; 0 )&#123; node.right = remove(node.right, e); return node; &#125; else&#123; // e.compareTo(node.e) == 0 // 待删除节点左子树为空的情况 if(node.left == null)&#123; Node rightNode = node.right; node.right = null; size --; return rightNode; &#125; // 待删除节点右子树为空的情况 if(node.right == null)&#123; Node leftNode = node.left; node.left = null; size --; return leftNode; &#125; // 待删除节点左右子树均不为空的情况 // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点 // 用这个节点顶替待删除节点的位置 Node successor = minimum(node.right); successor.right = removeMin(node.right); successor.left = node.left; node.left = node.right = null; return successor; &#125;&#125; 二分搜索树的时间复杂度分析添加操作：add(E e)：O(logn) 删除操作：remove(E e)：O(logn) 查询操作：contains(E e)：O(logn) 二分搜索树的顺序性二分搜索树当做查找表的一种实现。我们使用二分搜索树的目的是通过查找 key 马上得到 value。 二分搜索树还能回答哪些问题呢？这些问题都和顺序相关。 minimum，maximum successor，predecessor（这两个元素在二分搜索树的 key 中必须存在） floor（地板），ceil（天花板）（这两个元素在二分搜索树的 key 中可以存在，也可以不存在） rank（58 是排名第几的元素）、select（排名第10的元素是谁） 在有些情况下，我们须要支持重复元素的二分搜索树 . 二分搜索树的局限性二分搜索树可能会退化成链表。而通过对二分搜索树的时间复杂度分析，二分搜索树的查找过程是跟其高度有关的. 为了解决此问题，可以改造二叉树的实现，使得其无法退化成链表—–平衡二叉树，它有左右两棵子树，并且其高度差不会超过1，因此可以保证其高度一定是 logn 级别的，此概念的经典实现就是红黑树。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表]]></title>
    <url>%2F2019%2F09%2F08%2F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表什么是单链表单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的元素。它的数据是以结点来表示的，每个结点的构成：数据（类型为要存储的数据的类型） + 指针，数据就是链表里具体要存储的东西，指针就是用来把每个节点都连接起来，使它们形成一个链状。 单链表的结构12345678910111213141516171819202122232425262728293031323334353637383940414243public class LinkedList&lt;E&gt; &#123; //数据存储在节点中（内部类） private class Node&#123; public E e; public Node next; public Node(E e, Node next)&#123; this.e = e; this.next = next; &#125; public Node(E e)&#123; this(e, null); &#125; public Node()&#123; this(null, null); &#125; @Override public String toString()&#123; return e.toString(); &#125; &#125; //这里用的是虚拟头节点，不存储数据，便于操作在头部删除和添加元素 private Node dummyHead; private int size; public LinkedList()&#123; dummyHead = new Node(); size = 0; &#125; // 获取链表中的元素个数 public int getSize()&#123; return size; &#125; // 返回链表是否为空 public boolean isEmpty()&#123; return size == 0; &#125;&#125; 单链表的常用操作添加元素操作思路：找到要添加节点的前一个节点 123Node node = new Node(e,null);node.next = prev.next;prev.next = node; 具体java代码实现： 1234567891011121314151617181920212223// 在链表的index(0-based)位置添加新的元素epublic void add(int index, E e)&#123; if(index &lt; 0 || index &gt; size) throw new IllegalArgumentException("Add failed. Illegal index."); Node prev = dummyHead; for(int i = 0 ; i &lt; index ; i ++) prev = prev.next; prev.next = new Node(e, prev.next); size ++;&#125;// 在链表头添加新的元素epublic void addFirst(E e)&#123; add(0, e);&#125;// 在链表末尾添加新的元素epublic void addLast(E e)&#123; add(size, e);&#125; 查询元素操作 1234567891011121314151617181920212223242526272829303132// 获得链表的第index(0-based)个位置的元素public E get(int index)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Get failed. Illegal index."); Node cur = dummyHead.next; for(int i = 0 ; i &lt; index ; i ++) cur = cur.next; return cur.e;&#125;// 获得链表的第一个元素public E getFirst()&#123; return get(0);&#125;// 获得链表的最后一个元素public E getLast()&#123; return get(size - 1);&#125;// 查找链表中是否有元素epublic boolean contains(E e)&#123; Node cur = dummyHead.next; while(cur != null)&#123; if(cur.e.equals(e)) return true; cur = cur.next; &#125; return false;&#125; 修改元素操作 12345678910// 修改链表的第index(0-based)个位置的元素为epublic void set(int index, E e)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Set failed. Illegal index."); Node cur = dummyHead.next; for(int i = 0 ; i &lt; index ; i ++) cur = cur.next; cur.e = e;&#125; 删除元素操作思路：找到要删除的节点的前一个节点 123Node delNode = prev.next;prev.next = delNode.next;delNode.next = null 具体java代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 从链表中删除index(0-based)位置的元素, 返回删除的元素public E remove(int index)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Remove failed. Index is illegal."); Node prev = dummyHead; for(int i = 0 ; i &lt; index ; i ++) prev = prev.next; Node retNode = prev.next; prev.next = retNode.next; retNode.next = null; size --; return retNode.e;&#125;// 从链表中删除第一个元素, 返回删除的元素public E removeFirst()&#123; return remove(0);&#125;// 从链表中删除最后一个元素, 返回删除的元素public E removeLast()&#123; return remove(size - 1);&#125;// 从链表中删除元素epublic void removeElement(E e)&#123; Node prev = dummyHead; while(prev.next != null)&#123; if(prev.next.e.equals(e)) break; prev = prev.next; &#125; if(prev.next != null)&#123; Node delNode = prev.next; prev.next = delNode.next; delNode.next = null; size --; &#125;&#125; 单链表的时间复杂度分析添加操作：O(n) addLast(e)：O(n) addFirst(e)：O(1) add(index,e)：O(n/2) 删除操作：O(n) removeLast(e)：O(n) removeFirst(e)：O(1) remove(index,e)：O(n/2) 修改操作：O(n) set(index,e)：O(n) 查找操作：O(n) get(index)：O(n) contains(e)：O(n) 数组和链表的比较数组：优点：使用方便，查询效率比链表高，内存为一连续的区域。 缺点：大小固定，不适合动态存储，不方便动态添加。 动态数组优点：查找方便，适合随机查询。（查询快）。 缺点：插入，删除操作不方便，因为插入，删除操作会导致大量元素的移动。 链表优点：真正的动态，不需要处理固定容量的问题。插入，删除方便，不会导致元素的移动，因为元素增减，只需要调整指针。 缺点：丧失了随机访问的能力（查询慢）。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态数组]]></title>
    <url>%2F2019%2F09%2F08%2F%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[动态数组数组的特点优点： 按照索引查询数据元素速度快 能存储大量数据 按照索引遍历数组方便 缺点： 根据内容查找元素速度慢 数组的大小一经确定不能改变（数组的局限性） 数组只能存储一种类型的数据 增加，删除元素效率慢 未封装任何方法，所有操作都需要用户自己定义 12345678910111213141516171819202122232425262728293031public class Array&lt;E&gt; &#123; private E[] data; private int size; // 构造函数，传入数组的容量capacity构造Array public Array(int capacity)&#123; data = (E[])new Object[capacity]; size = 0; &#125; // 无参数的构造函数，默认数组的容量capacity=10 public Array()&#123; this(10); &#125; // 获取数组的容量 public int getCapacity()&#123; return data.length; &#125; // 获取数组中的元素个数 public int getSize()&#123; return size; &#125; // 返回数组是否为空 public boolean isEmpty()&#123; return size == 0; &#125;&#125; 动态数组使得数组的容量是可以伸缩的。 实现动态数组的思路 定义一个新的容量newCapacity，以新容量开辟一个新数组newData 遍历原数组data的元素，赋值到新数组newData中 将原数组的指针指向新数组 12345678// 将数组空间的容量变成newCapacity大小private void resize(int newCapacity)&#123;E[] newData = (E[])new Object[newCapacity];for(int i = 0 ; i &lt; size ; i ++) newData[i] = data[i]; data = newData;&#125; 动态数组的常见操作添加元素操作1234567891011121314151617181920212223242526// 在index索引的位置插入一个新元素epublic void add(int index, E e)&#123; if(index &lt; 0 || index &gt; size) throw new IllegalArgumentException("Add failed. Require index &gt;= 0 and index &lt;= size."); if(size == data.length) resize(2 * data.length);//扩充数组的容量 for(int i = size - 1; i &gt;= index ; i --) data[i + 1] = data[i]; data[index] = e; size ++;&#125;// 向所有元素后添加一个新元素public void addLast(E e)&#123; add(size, e);&#125;// 在所有元素前添加一个新元素public void addFirst(E e)&#123; add(0, e);&#125; 删除元素操作1234567891011121314151617181920212223242526272829303132// 从数组中删除index位置的元素, 返回删除的元素public E remove(int index)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Remove failed. Index is illegal."); E ret = data[index]; for(int i = index + 1 ; i &lt; size ; i ++) data[i - 1] = data[i]; size --; data[size] = null; // loitering objects != memory leak if(size == data.length / 4 &amp;&amp; data.length / 2 != 0)//为何要如此判断，下面有分析 resize(data.length / 2); return ret;&#125;// 从数组中删除第一个元素, 返回删除的元素public E removeFirst()&#123; return remove(0);&#125;// 从数组中删除最后一个元素, 返回删除的元素public E removeLast()&#123; return remove(size - 1);&#125;// 从数组中删除元素epublic void removeElement(E e)&#123; int index = find(e); if(index != -1) remove(index);&#125; 更改元素操作123456// 修改index索引位置的元素为epublic void set(int index, E e)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Set failed. Index is illegal."); data[index] = e;&#125; 查询元素123456789101112131415161718192021222324// 获取index索引位置的元素public E get(int index)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Get failed. Index is illegal."); return data[index];&#125;// 查找数组中是否有元素epublic boolean contains(E e)&#123; for(int i = 0 ; i &lt; size ; i ++)&#123; if(data[i].equals(e)) return true; &#125; return false;&#125;// 查找数组中元素e所在的索引，如果不存在元素e，则返回-1public int find(E e)&#123; for(int i = 0 ; i &lt; size ; i ++)&#123; if(data[i].equals(e)) return i; &#125; return -1;&#125; 动态数组时间复杂度分析添加元素操作：O(n) addLast(e)：O(1) addFirst(e)：O(n) add(index,e)：O(n/2) 删除元素操作：O(n) removeLast(e)：O(1) removeFirst(e)：O(n) remove(index,e)：O(n/2) 修改元素操作：已知索引：O(1)；未知索引：O(n) set(index,e)：O(1) 查找元素操作：已知索引O(1)；未知索引O(n) get(index)：O(1) contains(e):：O(n) find(e)：O(n) resize()时间复杂度分析 resize()：O(n) 从均摊复杂度的角度看addLast操作和removeLast操作 假设capacity=n，n+1次addLast，触发resize，而resize操作了n次，所以总共进行2n+1次基本操作，使用均摊复杂度均摊计算，每次addLast操作，进行2次基本操作，时间复杂度为O(1)。同理，我们看removeLast操作，均摊复杂度后的时间复杂度也为O(1). 防止复杂度震荡 出现复杂度震荡的问题描述： 假设现在我们有一个数组，容量是n，并且装满了元素。这时候，我想添加一个元素，显然是需要进行扩容，容量变为2n，耗时O(n)的时间。但是此时，我又删除了一个元素触发了缩容操作，耗时O(n)的时间。当我们每次触发缩容或扩容操作，都会耗费O(n)额复杂度，那么这便是复杂度的震荡。 分析原因：在特殊情况下，我们频繁的添加和删减操作，导致过于着急的去扩容或缩容。 解决方案： 可以采用一种相对懒惰(Lazy机制)的策略。 比如说，一个满的数组，容量n，添加元素需要进行扩容，容量变为2n。但在这时，在进行删除元素后，不立即进行缩容操作，而是再等等。如果后面一直有删除操作的话，删除到整个数组容积的1/4，再触发缩容操作。缩容数组的1/2，而不是直接缩容到1/4。此时，数组中存在1/4的元素，还预留了1/4的空间。通过这样的策略，防止了复杂度的震荡，从而有效的提升整体的性能。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
