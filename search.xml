<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java_排序]]></title>
    <url>%2F2019%2F09%2F08%2Fjava%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序思路 比较相邻的元素，如果第一个比第二个大，就交换它们两个。 对每一对相邻元素做同样的工作，从第一对到最后一对，这样2在最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个元素。 重复步骤1—3,直到排序完成。 java代码具体实现12345678910111213public class BubbleSort&#123; public static void sort(int[] arr)&#123; for(int i = 0;i&lt;arr.length-1;i++)&#123; for(int j = 0;j&lt;arr.length-1-i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; &#125;&#125; 选择排序思路把第一个元素依次和后面的所有元素进行比较。第一次结束后，就会有最小值出现在最前面。 java代码具体实现12345678910111213public class SelectionSort&#123; public static void sort(int[] arr)&#123; for(int i = 0;i&lt;arr.length-1;i++)&#123; for(int j = i+1;j&lt;arr.length;j++)&#123; if(arr[j]&lt;arr[i])&#123; int temp = arr[j]; arr[j] = arr[i]; arr[i] = temp; &#125; &#125; &#125; &#125;&#125; 插入排序思路1234567891011将n个元素的数列分为已有序和无序两个部分，如插入排序过程示例下所示： &#123;&#123;a1&#125;，&#123;a2，a3，a4，…，an&#125;&#125; &#123;&#123;a1⑴，a2⑴&#125;，&#123;a3⑴，a4⑴ …，an⑴&#125;&#125; &#123;&#123;a1(n-1），a2(n-1) ，…&#125;,&#123;an(n-1)&#125;&#125; 每次处理就是将无序数列的第一个元素与有序数列的元素从后往前逐个进行比较，找出插入位置，将该元素插入到有序数列的合适位置中。 java具体代码实现1234567891011public class InsertSort&#123; public static void sort(int[] arr)&#123; for(int i = 1;i&lt;arr.length;i++)&#123; for(int j = i;(j&gt;=1)&amp;&amp;(arr[j]&lt;arr[j-1]);j--)&#123; int temp = arr[j]; arr[j] = arr[j-1]; arr[j-1] = temp; &#125; &#125; &#125;&#125; 希尔排序思路 先取一个小于n的整数d1作为第一个增量 把文件的全部记录分为（n除以d1）个组。所有距离为dl的倍数的记录放在同一个组中 先在各组内进行直接插入排序，然后，取第二个增量d2&lt;d1，重复上述的分组和排序 直至所取的增量dt = 1，即所有记录放在同一组中进行直接插入排序即可。 java具体代码实现1234567891011121314151617181920public class ShellSort&#123; public static void sort(int[] arr)&#123; for(int i = arr.length/2;i&gt;2;i/=2)&#123; for(int j = 0;j&lt;i;j++)&#123; insertSort(arr,j,i); &#125; &#125; insertSort(arr,0,1); &#125; private static void insertSort(int[] arr,int start;int inc)&#123; for(int i = start+inc;i&lt;arr.length;i+=inc)&#123; for(int j = i;(j&gt;=inc)&amp;&amp;(arr[j]&lt;arr[j-inc]);j-=inc)&#123; int temp = arr[j]; arr[j] = arr[j-inc]; arr[j-inc] = temp; &#125; &#125; &#125;&#125; 快速排序思路一趟快速排序的算法如下： 设置两个变量i、j，排序开始的时候：i=0，j=N-1； 以第一个数组元素作为关键数据，赋值给key，即 key=A[0]； 从j开始向前搜索，即由后开始向前搜索（j=j-1即j–），找到第一个小于key的值A[j]，A[i]与A[j]交换； 从i开始向后搜索，即由前开始向后搜索（i=i+1即i++），找到第一个大于key的A[i]，A[i]与A[j]交换； 重复第3、4、5步，直到 i=j； ==3,4步是在程序中没找到时候j=j-1，i=i+1，直至找到为止。找到并交换的时候i， j指针位置不变。另外当i=j这过程一定正好是i+或j-完成的最后令循环结束== java具体代码实现12345678910111213141516171819202122232425262728293031public class QuickSort&#123; public static void sort(int[] arr)&#123; quickSort(arr,0,arr.length-1); &#125; private static void quickSort(int[] arr,int low,int high)&#123; int i = low; int j = high; int temp = arr[i]; while(i &lt; j)&#123; while(i &lt; j &amp;&amp; temp &lt; arr[j])&#123; j--; &#125; if(i&lt;j)&#123; arr[i] = arr[j]; i++; &#125; while(i&lt;j &amp;&amp; temp &gt; arr[i])&#123; i++; &#125; if(i &lt; j)&#123; arr[j] = arr[i]; &#125; &#125; arr[i] = temp; if(low&lt;i) quickSort(arr,low,i-1); if(i&lt;high) quickSort(arr,j+1,high); &#125;&#125; 堆排序思路堆排序利用了大根堆（或小根堆）堆顶记录的关键字最大（或最小）这一特征， 使得在当前无序区中选取最大（或最小）关键字的记录变得简单。 java具体代码实现123456789101112131415161718192021222324252627282930313233343536public class HeapSort&#123; public static sort(int[] arr)&#123; initMaxHeap(arr,arr.length); for(int i = arr.length-1;i&gt;0;i--)&#123; int temp = arr[0]; arr[] = arr[i]; arr[i] = temp; createMaxHeap(arr,i,0); &#125; &#125; // 初始化创建最大堆 //从第1个非叶子节点a[h]开始到a[0]为止调用createMaxHeap函数的过程 private void initMaxHeap(int[] arr,int n)&#123; for(int i = (n-2)/2;i&gt;=0;i--) createMaxHeap(arr,n,i); &#125; //调整长度为n的数组arr，使非叶子节点a[h]为根的二叉树满足最大堆 private static void createMaxHeap(int[] arr,int n,int h)&#123; int i = h; int j = 2*i+1; int temp = arr[i]; boolean flag = false; while(j&lt;n&amp;&amp;!flag)&#123; if(j+1&lt;n &amp;&amp; arr[j]&lt;arr[j+1]) j++; if(temp&gt;arr[j]) flag = true; else&#123; arr[i] = arr[j]; i = j; j = 2*i+1; &#125; &#125; arr[i] = temp; &#125;&#125; 归并排序定义归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 算法描述 把长度为n的输入序列分成两个长度为n/2的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。 java代码具体实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MergeSort&#123; public static void sort(int[] arr)&#123; //先创建一个临时数组，是为了避免在递归的过程中频繁开辟空间 int[] temp = new int[arr.length]; mergeSort(arr,0,arr.length-1,temp); &#125; private static void mergeSort(int[] arr,int[] temp,int left,int right)&#123; if(left&lt;right)&#123; int mid = (left+right)/2; //对左边子序列进行归并排序，使之有序 mergeSort(arr,temp,left,mid); //对右边子序列进行归并排序，使之有序 mergeSort(arr,temp,mid+1,right); //对左右两个有序子序列进行合并 merge(arr,temp,left,mid,right); &#125; &#125; private static void merge(int[] arr,int[] temp,int left,int mid,int right)&#123; int i = left; //左边子序列的指针 int j = mid+1; //右边子序列的指针 int t = 0; //临时数组指针 while(i&lt;=mid &amp;&amp; j&lt;= right)&#123; if(arr[i]&lt;=arr[j])&#123; temp[t++]=arr[i++]; &#125; else&#123; temp[t++]=arr[j++]; &#125; &#125; //情况1：若当右子序列已全部填充进临时数组，将左子序列填充进临时数组 while (i &lt;= mid) &#123; temp[t++] = arr[i++]; &#125; //情况2：若当左子序列已全部填充进临时数组，将右子序列填充进临时数组 while (j&lt;=right) &#123; temp[t++] = arr[j++]; &#125; //将临时数组指针初始化为0 t = 0; while(left&lt;=right)&#123; arr[left++] = temp[t++]; &#125; &#125;&#125; 计数排序计数排序适用的数据范围计数排序需要占用大量空间，它仅适用于数据比较集中的情况。比如 [0100]，[1000019999] 这样的数据。 计数排序、基数排序、桶排序则属于非比较排序。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。 非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。 过程分析计数排序的基本思想是：对每一个输入的元素arr[i]，确定小于 arr[i] 的元素个数。所以可以直接把 arr[i] 放到它输出数组中的位置上。假设有5个数小于 arr[i]，所以 arr[i] 应该放在数组的第6个位置上。 需要三个数组： 待排序数组 int[] arr = new int[]{4,3,6,3,5,1}; 辅助计数数组 int[] help = new int[max - min + 1]; //该数组大小为待排序数组中的最大值减最小值+1 输出数组 int[] res = new int[arr.length]; 求出待排序数组的最大值max=6， 最小值min=1 实例化辅助计数数组help，help用来记录每个元素之前出现的元素个数 计算 arr 每个数字应该在排序后数组中应该处于的位置，此时 help = [1,1,4,5,6,7]; 根据 help 数组求得排序后的数组，此时 res = [1,3,3,4,5,6] java具体代码实现123456789101112131415161718192021222324252627282930313233public class CountSort&#123; public static void sort(int[] arr)&#123; int max = Integer.MIN_VALUE; int min = Integer.MAX_VALUE; //找出数组中的最大值和最小值 for(int i = 0;i&lt;arr.length;i++)&#123; max = Math.max(max,arr[i]); min = Math.min(min,arr[i]); &#125; // int[] help = new int[max-min+1]; //找出每个数字出现的次数 for(int i = 0;i&lt;arr.length;i++)&#123; int mapPos = arr[i]-min; help[mapPos]++; &#125; //计算每个数字应该在排序后数组中应该处于的位置 for(int i = 1;i&lt;help.length;i++)&#123; help[i] = help[i-1]+help[i]; &#125; //根据help数组进行排序 int res[] = new int[arr.length]; for(int i = 0;i&lt;arr.length;i++)&#123; int pos = --help[arr[i]-min]; res[pos] = arr[i]; &#125; arr = res; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[队列]]></title>
    <url>%2F2019%2F09%2F08%2F%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[队列什么是队列队列也是一种线性结构。相比数组，队列对应的操作是数组的子集。只能从一端（队尾）添加元素，只能从另一端（队头）取出元素。是一种先进先出的数据结构。 队列底层的实现队列底层的实现可以是动态数组和链表。 队列常见的一些方法12345678public interface Queue&lt;E&gt; &#123; int getSize(); boolean isEmpty(); void enqueue(E e); E dequeue(); E getFront();&#125; 动态数组实现的队列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class ArrayQueue&lt;E&gt; implements Queue&lt;E&gt; &#123; //Array代码可以观看我之前写过的动态数组代码或者可以用java的集合类ArrayList private Array&lt;E&gt; array; public ArrayQueue(int capacity)&#123; array = new Array&lt;&gt;(capacity); &#125; public ArrayQueue()&#123; array = new Array&lt;&gt;(); &#125; @Override public int getSize()&#123; return array.getSize(); &#125; @Override public boolean isEmpty()&#123; return array.isEmpty(); &#125; public int getCapacity()&#123; return array.getCapacity(); &#125; @Override public void enqueue(E e)&#123; array.addLast(e); &#125; @Override public E dequeue()&#123; return array.removeFirst(); &#125; @Override public E getFront()&#123; return array.getFirst(); &#125; @Override public String toString()&#123; StringBuilder res = new StringBuilder(); res.append("Queue: "); res.append("front ["); for(int i = 0 ; i &lt; array.getSize() ; i ++)&#123; res.append(array.get(i)); if(i != array.getSize() - 1) res.append(", "); &#125; res.append("] tail"); return res.toString(); &#125; 动态数组实现的队列时间复杂度分析：除了出队时间复杂度是O(n)，其他操作是O(1) 链表实现的队列1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class LinkedListQueue&lt;E&gt; implements Queue&lt;E&gt; &#123; private class Node&#123; public E e; public Node next; public Node(E e, Node next)&#123; this.e = e; this.next = next; &#125; public Node(E e)&#123; this(e, null); &#125; public Node()&#123; this(null, null); &#125; @Override public String toString()&#123; return e.toString(); &#125; &#125; private Node head, tail; private int size; public LinkedListQueue()&#123; head = null; tail = null; size = 0; &#125; @Override public int getSize()&#123; return size; &#125; @Override public boolean isEmpty()&#123; return size == 0; &#125; @Override public void enqueue(E e)&#123; if(tail == null)&#123; tail = new Node(e); head = tail; &#125; else&#123; tail.next = new Node(e); tail = tail.next; &#125; size ++; &#125; @Override public E dequeue()&#123; if(isEmpty()) throw new IllegalArgumentException("Cannot dequeue from an empty queue."); Node retNode = head; head = head.next; retNode.next = null; if(head == null) tail = null; size --; return retNode.e; &#125; @Override public E getFront()&#123; if(isEmpty()) throw new IllegalArgumentException("Queue is empty."); return head.e; &#125; @Override public String toString()&#123; StringBuilder res = new StringBuilder(); res.append("Queue: front "); Node cur = head; while(cur != null) &#123; res.append(cur + "-&gt;"); cur = cur.next; &#125; res.append("NULL tail"); return res.toString(); &#125;&#125; 用上述链表的形式实现的队列的方法时间复杂度都为O(1)。原因是添加了一个指向链表尾部的指针，用来解决入队的时间复杂度，把原为O(n)变为O(1)。 循环队列用来解决动态数组实现的队列出队的时间复杂度问题。 两个判断条件要弄清楚： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class LoopQueue&lt;E&gt; implements Queue&lt;E&gt; &#123; private E[] data; private int front, tail; private int size; public LoopQueue(int capacity)&#123; data = (E[])new Object[capacity + 1]; front = 0; tail = 0; size = 0; &#125; public LoopQueue()&#123; this(10); &#125; public int getCapacity()&#123; return data.length - 1; &#125; @Override public boolean isEmpty()&#123; return front == tail; &#125; @Override public int getSize()&#123; return size; &#125; @Override public void enqueue(E e)&#123; if((tail + 1) % data.length == front) resize(getCapacity() * 2); data[tail] = e; tail = (tail + 1) % data.length; size ++; &#125; @Override public E dequeue()&#123; if(isEmpty()) throw new IllegalArgumentException("Cannot dequeue from an empty queue."); E ret = data[front]; data[front] = null; front = (front + 1) % data.length; size --; if(size == getCapacity() / 4 &amp;&amp; getCapacity() / 2 != 0) resize(getCapacity() / 2); return ret; &#125; @Override public E getFront()&#123; if(isEmpty()) throw new IllegalArgumentException("Queue is empty."); return data[front]; &#125; private void resize(int newCapacity)&#123; E[] newData = (E[])new Object[newCapacity + 1]; for(int i = 0 ; i &lt; size ; i ++) newData[i] = data[(i + front) % data.length]; data = newData; front = 0; tail = size; &#125; @Override public String toString()&#123; StringBuilder res = new StringBuilder(); res.append(String.format("Queue: size = %d , capacity = %d\n", size, getCapacity())); res.append("front ["); for(int i = front ; i != tail ; i = (i + 1) % data.length)&#123; res.append(data[i]); if((i + 1) % data.length != tail) res.append(", "); &#125; res.append("] tail"); return res.toString(); &#125;&#125; 循环队列的时间复杂度分析：采用均摊复杂度，我们可以发现出队和入队的时间复杂度都为O(1)。所以循环队列的相关操作的时间复杂度都为O(1)。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈]]></title>
    <url>%2F2019%2F09%2F08%2F%E6%A0%88%2F</url>
    <content type="text"><![CDATA[栈什么是栈栈是一种特殊的线性表，仅允许在表的一端进行插入和删除运算。这一端被称为栈顶（top），相对地，把另一端称为栈底（bottom）。向一个栈插入新元素又称作进栈、入栈或压栈（push），它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈（pop），它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。所以栈具有“后入先出”的特点（LIFO）。 栈底层的实现栈的底层实现可以是动态数组和链表 栈常见的一些方法12345678public interface Stack&lt;E&gt; &#123; int getSize(); boolean isEmpty(); void push(E e); E pop(); E peek();&#125; 动态数组实现的栈12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class ArrayStack&lt;E&gt; implements Stack&lt;E&gt; &#123; private Array&lt;E&gt; array; public ArrayStack(int capacity)&#123; array = new Array&lt;&gt;(capacity); &#125; public ArrayStack()&#123; array = new Array&lt;&gt;(); &#125; @Override public int getSize()&#123; return array.getSize(); &#125; @Override public boolean isEmpty()&#123; return array.isEmpty(); &#125; public int getCapacity()&#123; return array.getCapacity(); &#125; @Override public void push(E e)&#123; array.addLast(e); &#125; @Override public E pop()&#123; return array.removeLast(); &#125; @Override public E peek()&#123; return array.getLast(); &#125; @Override public String toString()&#123; StringBuilder res = new StringBuilder(); res.append("Stack: "); res.append('['); for(int i = 0 ; i &lt; array.getSize() ; i ++)&#123; res.append(array.get(i)); if(i != array.getSize() - 1) res.append(", "); &#125; res.append("] top"); return res.toString(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156//动态数组的实现public class Array&lt;E&gt; &#123; private E[] data; private int size; // 构造函数，传入数组的容量capacity构造Array public Array(int capacity)&#123; data = (E[])new Object[capacity]; size = 0; &#125; // 无参数的构造函数，默认数组的容量capacity=10 public Array()&#123; this(10); &#125; // 获取数组的容量 public int getCapacity()&#123; return data.length; &#125; // 获取数组中的元素个数 public int getSize()&#123; return size; &#125; // 返回数组是否为空 public boolean isEmpty()&#123; return size == 0; &#125; // 在index索引的位置插入一个新元素e public void add(int index, E e)&#123; if(index &lt; 0 || index &gt; size) throw new IllegalArgumentException("Add failed. Require index &gt;= 0 and index &lt;= size."); if(size == data.length) resize(2 * data.length); for(int i = size - 1; i &gt;= index ; i --) data[i + 1] = data[i]; data[index] = e; size ++; &#125; // 向所有元素后添加一个新元素 public void addLast(E e)&#123; add(size, e); &#125; // 在所有元素前添加一个新元素 public void addFirst(E e)&#123; add(0, e); &#125; // 获取index索引位置的元素 public E get(int index)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Get failed. Index is illegal."); return data[index]; &#125; public E getLast()&#123; return get(size - 1); &#125; public E getFirst()&#123; return get(0); &#125; // 修改index索引位置的元素为e public void set(int index, E e)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Set failed. Index is illegal."); data[index] = e; &#125; // 查找数组中是否有元素e public boolean contains(E e)&#123; for(int i = 0 ; i &lt; size ; i ++)&#123; if(data[i].equals(e)) return true; &#125; return false; &#125; // 查找数组中元素e所在的索引，如果不存在元素e，则返回-1 public int find(E e)&#123; for(int i = 0 ; i &lt; size ; i ++)&#123; if(data[i].equals(e)) return i; &#125; return -1; &#125; // 从数组中删除index位置的元素, 返回删除的元素 public E remove(int index)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Remove failed. Index is illegal."); E ret = data[index]; for(int i = index + 1 ; i &lt; size ; i ++) data[i - 1] = data[i]; size --; data[size] = null; // loitering objects != memory leak if(size == data.length / 4 &amp;&amp; data.length / 2 != 0) resize(data.length / 2); return ret; &#125; // 从数组中删除第一个元素, 返回删除的元素 public E removeFirst()&#123; return remove(0); &#125; // 从数组中删除最后一个元素, 返回删除的元素 public E removeLast()&#123; return remove(size - 1); &#125; // 从数组中删除元素e public void removeElement(E e)&#123; int index = find(e); if(index != -1) remove(index); &#125; @Override public String toString()&#123; StringBuilder res = new StringBuilder(); res.append(String.format("Array: size = %d , capacity = %d\n", size, data.length)); res.append('['); for(int i = 0 ; i &lt; size ; i ++)&#123; res.append(data[i]); if(i != size - 1) res.append(", "); &#125; res.append(']'); return res.toString(); &#125; // 将数组空间的容量变成newCapacity大小 private void resize(int newCapacity)&#123; E[] newData = (E[])new Object[newCapacity]; for(int i = 0 ; i &lt; size ; i ++) newData[i] = data[i]; data = newData; &#125;&#125; 栈应用的一些场景编辑器的撤销操作 系统调用栈 编译器的括号匹配 如下题： 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 12345678910111213141516171819202122232425262728293031class Solution &#123; public boolean isValid(String s) &#123; ArrayStack&lt;Character&gt; stack = new ArrayStack&lt;&gt;(); for(int i = 0 ; i &lt; s.length() ; i ++)&#123; char c = s.charAt(i); if(c == '(' || c == '[' || c == '&#123;') stack.push(c); else&#123; if(stack.isEmpty()) return false; char topChar = stack.pop(); if(c == ')' &amp;&amp; topChar != '(') return false; if(c == ']' &amp;&amp; topChar != '[') return false; if(c == '&#125;' &amp;&amp; topChar != '&#123;') return false; &#125; &#125; return stack.isEmpty(); &#125; public static void main(String[] args) &#123; System.out.println((new Solution()).isValid("()[]&#123;&#125;")); System.out.println((new Solution()).isValid("([)]")); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分搜索树]]></title>
    <url>%2F2019%2F09%2F08%2F%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[为什么要有树结构树结构本身是一种天然的组织结构。将数据使用数结构存储后，会很高效 二叉树特性： 二叉树和链表一样，是动态数据结构。 二叉树具有唯一根节点。每个节点最多有两个孩子，最多有一个父亲。 二叉树具有天然的递归结构。 满二叉树：在一棵二叉树中，如果所有分支节点都存在左子树和右子树，并且所有叶子节点都在同一层上。这样的二叉树称作满二叉树。 完全二叉树：如果一个具有n个节点的二叉树与满二叉树的前n个节点的结构相同，这样的二叉树被称为完全二叉树。 12345class Node&#123; E e; Node left;//左孩子 Node right;//右孩子&#125; 二分搜索树BST特性1）二分搜索树每个节点的值：大于左子树的所有节点的值；小于其右子树节点的值。 2）每一棵子树也是二分搜索树 3)）存储的元素必须有可比性 12345678910111213141516171819202122232425262728//实现Compareble接口是为了让存储的元素具有可比性public class BST&lt;E extends Comparable&lt;E&gt;&gt; &#123; //成员内部类 private class Node &#123; public E e; public Node left, right; public Node(E e) &#123;//Node类初始化 this.e = e; left = null; right = null; &#125; &#125; //成员变量 private Node root; //根节点 private int size; //元素个数 public BST()&#123; //BST初始化 root = null; size = 0; &#125; //返回元素个数 public int size()&#123; return size; &#125; //判断BST是否为空 public boolean isEmpty()&#123; return size == 0; &#125;&#125; 添加新元素代码讲解的是不包含重复元素和采用递归的写法。 如果想包含重复元素，只需定义左子树小于等于节点，或右子树大于等于节点。二分搜索树添加元素的非递归写法和链表很像。 思想：从根节点开始找插入的位置，满足二叉搜索树的特性，比左子节点大，比右子节点小。 步骤： 从根节点开始，先比较当前节点，如果当前节点为null那么很明显就应该插入到这个节点。 如果上面的节点不是null，那么和当前节点比较，如果小于节点就往左子树放，如果大于节点就往右子树放。 然后分别对左子树或者右子树递归的递归进行如上1、2步骤的操作。 123456789101112131415161718192021222324252627282930// 向二分搜索树中添加新的元素epublic void add(E e)&#123; if(root == null)&#123; root = new Node(e); size ++; &#125; else add(root, e);&#125;// 向以node为根的二分搜索树中插入元素e，递归算法private void add(Node node, E e)&#123; //求解最基本问题 if(e.equals(node.e)) return; else if(e.compareTo(node.e) &lt; 0 &amp;&amp; node.left == null)&#123; node.left = new Node(e); size ++; return; &#125; else if(e.compareTo(node.e) &gt; 0 &amp;&amp; node.right == null)&#123; node.right = new Node(e); size ++; return; &#125; //把原问题转化为更小的问题 if(e.compareTo(node.e) &lt; 0) add(node.left, e); else //e.compareTo(node.e) &gt; 0 add(node.right, e);&#125; 添加元素java代码改进版： 1234567891011121314151617181920// 向二分搜索树中添加新的元素epublic void add(E e)&#123; root = add(root, e);&#125;// 向以node为根的二分搜索树中插入元素e，递归算法// 返回插入新节点后二分搜索树的根private Node add(Node node, E e)&#123; //求解最基本问题 if(node == null)&#123; size ++; return new Node(e); &#125; //把原问题转化为更小的问题 if(e.compareTo(node.e) &lt; 0) node.left = add(node.left, e); else if(e.compareTo(node.e) &gt; 0) node.right = add(node.right, e); return node;&#125; 查询元素12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 看二分搜索树中是否包含元素epublic boolean contains(E e)&#123; return contains(root, e);&#125;// 看以node为根的二分搜索树中是否包含元素e, 递归算法private boolean contains(Node node, E e)&#123; //求解最基本问题 if(node == null) return false; //把原问题转化为更小的问题 if(e.compareTo(node.e) == 0) return true; else if(e.compareTo(node.e) &lt; 0) return contains(node.left, e); else // e.compareTo(node.e) &gt; 0 return contains(node.right, e);&#125;// 寻找二分搜索树的最小元素public E minimum()&#123; if(size == 0) throw new IllegalArgumentException("BST is empty!"); return minimum(root).e;&#125;// 返回以node为根的二分搜索树的最小值所在的节点private Node minimum(Node node)&#123; if(node.left == null) return node; return minimum(node.left);&#125;// 寻找二分搜索树的最大元素public E maximum()&#123; if(size == 0) throw new IllegalArgumentException("BST is empty"); return maximum(root).e;&#125;// 返回以node为根的二分搜索树的最大值所在的节点private Node maximum(Node node)&#123; if(node.right == null) return node; return maximum(node.right);&#125; 遍历遍历操作就是把所有节点都访问一遍(访问的原因和业务有关)，在线性结构下，遍历是极其简单的（for循环）。 树结构的遍历操作，两棵子树都要顾及。 前序遍历：若二叉树为空，则算法结束，否则：1）访问根节点。2）前序遍历根节点的左子树。3）前序遍历根节点的右子树。 1234567891011121314// 二分搜索树的前序遍历public void preOrder()&#123; preOrder(root);&#125;// 前序遍历以node为根的二分搜索树, 递归算法private void preOrder(Node node)&#123; if(node == null) return; System.out.println(node.e); preOrder(node.left); preOrder(node.right);&#125; 非递归的二叉树前序遍历算法 借助栈的数据结构来实现，步骤如下： 1）把根节点入栈 2）只要栈不为空，就依次把每个节点出栈 若该节点的右子树非空，将该右子树的根节点入栈 若该节点的左子树非空，将该左子树的根节点入栈 123456789101112131415// 二分搜索树的非递归前序遍历public void preOrderNR()&#123; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.isEmpty())&#123; Node cur = stack.pop(); System.out.println(cur.e); if(cur.right != null) stack.push(cur.right); if(cur.left != null) stack.push(cur.left); &#125;&#125; 中序遍历若二叉树为空，则算法结束，否则：1）中序遍历根节点的左子树。2）访问根节点。3）中序遍历根节点的右子树。 123456789101112// 二分搜索树的中序遍历public void inOrder()&#123; inOrder(root);&#125;// 中序遍历以node为根的二分搜索树, 递归算法private void inOrder(Node node)&#123; if(node == null) return; inOrder(node.left); System.out.println(node.e); inOrder(node.right);&#125; 后序遍历若二叉树为空，则算法结束，否则：1）后序遍历根节点的左子树。2）后序遍历根节点的右子树。3）访问根节点。 123456789101112// 二分搜索树的后序遍历public void postOrder()&#123; postOrder(root);&#125;// 后序遍历以node为根的二分搜索树, 递归算法private void postOrder(Node node)&#123; if(node == null) return; postOrder(node.left); postOrder(node.right); System.out.println(node.e);&#125; 层序遍历(广度优先遍历)利用队列的数据结构实现，步骤如下： 1）将根节点入队列 2）当队列不为空时，依次把队列中的节点出队列 若该节点的左子树不为空，将该左子树的根节点入队列 若该节点的右子树不为空，将该右子树的根节点入队列 123456789101112131415//二分搜索树的层序遍历public void leveOrder()&#123; if(root == null) return; Queue&lt;Node&gt; q = new LinkedList&lt;&gt;(); q.add(root); while(!q.isEmpty())&#123; Node cur = q.remove(); System.out.println(cur.e); if(cur.left!= null) q.add(cur.left); if(cur.right!=null) q.add(cur.right); &#125;&#125; 删除元素删除最小值所在节点思想：根据二分搜索树的特性，我们知道节点的左孩子小于该节点（依次递归，找到最小值) 12345678910111213141516171819202122// 从二分搜索树中删除最小值所在节点, 返回最小值public E removeMin()&#123; //寻找到二分搜索树中最小的元素 E ret = minimum(); root = removeMin(root); return ret;&#125;// 删除掉以node为根的二分搜索树中的最小节点// 返回删除节点后新的二分搜索树的根private Node removeMin(Node node)&#123; if(node.left == null)&#123; Node rightNode = node.right; node.right = null; size --; return rightNode; &#125; node.left = removeMin(node.left); return node;&#125; 删除最大值所在节点思想：根据二分搜索树的特性，我们知道节点的右孩子大于该节点（依次递归，找到最大值) 123456789101112131415161718192021// 从二分搜索树中删除最大值所在节点public E removeMax()&#123; E ret = maximum(); root = removeMax(root); return ret;&#125;// 删除掉以node为根的二分搜索树中的最大节点// 返回删除节点后新的二分搜索树的根private Node removeMax(Node node)&#123; if(node.right == null)&#123; Node leftNode = node.left; node.left = null; size --; return leftNode; &#125; node.right = removeMax(node.right); return node;&#125; 删除元素为e的节点分为三种情况 1）待删除元素的节点左子树为空 2）待删除元素的节点右子树为空 3）待删除元素的节点左右子树非空情况 1234567891011//第一种解法：找到待删除节点的后继节点来代替Node successor = minimum(node.right);successor.right = removeMin(node.right);successor.left = node.left;node.left = node.right = null;//第二种解法：找到待删除节点的前驱节点来代替Node precursor = maximum(node.left);precursor.left = removeMax(node.left);precursor.right = node.left;node.left = node.right = null; 具体java代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 从二分搜索树中删除元素为e的节点public void remove(E e)&#123; root = remove(root, e);&#125;// 删除掉以node为根的二分搜索树中值为e的节点, 递归算法// 返回删除节点后新的二分搜索树的根private Node remove(Node node, E e)&#123; if( node == null ) return null; if( e.compareTo(node.e) &lt; 0 )&#123; node.left = remove(node.left , e); return node; &#125; else if(e.compareTo(node.e) &gt; 0 )&#123; node.right = remove(node.right, e); return node; &#125; else&#123; // e.compareTo(node.e) == 0 // 待删除节点左子树为空的情况 if(node.left == null)&#123; Node rightNode = node.right; node.right = null; size --; return rightNode; &#125; // 待删除节点右子树为空的情况 if(node.right == null)&#123; Node leftNode = node.left; node.left = null; size --; return leftNode; &#125; // 待删除节点左右子树均不为空的情况 // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点 // 用这个节点顶替待删除节点的位置 Node successor = minimum(node.right); successor.right = removeMin(node.right); successor.left = node.left; node.left = node.right = null; return successor; &#125;&#125; 二分搜索树的时间复杂度分析添加操作：add(E e)：O(logn) 删除操作：remove(E e)：O(logn) 查询操作：contains(E e)：O(logn) 二分搜索树的顺序性二分搜索树当做查找表的一种实现。我们使用二分搜索树的目的是通过查找 key 马上得到 value。 二分搜索树还能回答哪些问题呢？这些问题都和顺序相关。 minimum，maximum successor，predecessor（这两个元素在二分搜索树的 key 中必须存在） floor（地板），ceil（天花板）（这两个元素在二分搜索树的 key 中可以存在，也可以不存在） rank（58 是排名第几的元素）、select（排名第10的元素是谁） 在有些情况下，我们须要支持重复元素的二分搜索树 . 二分搜索树的局限性二分搜索树可能会退化成链表。而通过对二分搜索树的时间复杂度分析，二分搜索树的查找过程是跟其高度有关的. 为了解决此问题，可以改造二叉树的实现，使得其无法退化成链表—–平衡二叉树，它有左右两棵子树，并且其高度差不会超过1，因此可以保证其高度一定是 logn 级别的，此概念的经典实现就是红黑树。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表]]></title>
    <url>%2F2019%2F09%2F08%2F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表什么是单链表单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的元素。它的数据是以结点来表示的，每个结点的构成：数据（类型为要存储的数据的类型） + 指针，数据就是链表里具体要存储的东西，指针就是用来把每个节点都连接起来，使它们形成一个链状。 单链表的结构12345678910111213141516171819202122232425262728293031323334353637383940414243public class LinkedList&lt;E&gt; &#123; //数据存储在节点中（内部类） private class Node&#123; public E e; public Node next; public Node(E e, Node next)&#123; this.e = e; this.next = next; &#125; public Node(E e)&#123; this(e, null); &#125; public Node()&#123; this(null, null); &#125; @Override public String toString()&#123; return e.toString(); &#125; &#125; //这里用的是虚拟头节点，不存储数据，便于操作在头部删除和添加元素 private Node dummyHead; private int size; public LinkedList()&#123; dummyHead = new Node(); size = 0; &#125; // 获取链表中的元素个数 public int getSize()&#123; return size; &#125; // 返回链表是否为空 public boolean isEmpty()&#123; return size == 0; &#125;&#125; 单链表的常用操作添加元素操作思路：找到要添加节点的前一个节点 123Node node = new Node(e,null);node.next = prev.next;prev.next = node; 具体java代码实现： 1234567891011121314151617181920212223// 在链表的index(0-based)位置添加新的元素epublic void add(int index, E e)&#123; if(index &lt; 0 || index &gt; size) throw new IllegalArgumentException("Add failed. Illegal index."); Node prev = dummyHead; for(int i = 0 ; i &lt; index ; i ++) prev = prev.next; prev.next = new Node(e, prev.next); size ++;&#125;// 在链表头添加新的元素epublic void addFirst(E e)&#123; add(0, e);&#125;// 在链表末尾添加新的元素epublic void addLast(E e)&#123; add(size, e);&#125; 查询元素操作 1234567891011121314151617181920212223242526272829303132// 获得链表的第index(0-based)个位置的元素public E get(int index)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Get failed. Illegal index."); Node cur = dummyHead.next; for(int i = 0 ; i &lt; index ; i ++) cur = cur.next; return cur.e;&#125;// 获得链表的第一个元素public E getFirst()&#123; return get(0);&#125;// 获得链表的最后一个元素public E getLast()&#123; return get(size - 1);&#125;// 查找链表中是否有元素epublic boolean contains(E e)&#123; Node cur = dummyHead.next; while(cur != null)&#123; if(cur.e.equals(e)) return true; cur = cur.next; &#125; return false;&#125; 修改元素操作 12345678910// 修改链表的第index(0-based)个位置的元素为epublic void set(int index, E e)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Set failed. Illegal index."); Node cur = dummyHead.next; for(int i = 0 ; i &lt; index ; i ++) cur = cur.next; cur.e = e;&#125; 删除元素操作思路：找到要删除的节点的前一个节点 123Node delNode = prev.next;prev.next = delNode.next;delNode.next = null 具体java代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 从链表中删除index(0-based)位置的元素, 返回删除的元素public E remove(int index)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Remove failed. Index is illegal."); Node prev = dummyHead; for(int i = 0 ; i &lt; index ; i ++) prev = prev.next; Node retNode = prev.next; prev.next = retNode.next; retNode.next = null; size --; return retNode.e;&#125;// 从链表中删除第一个元素, 返回删除的元素public E removeFirst()&#123; return remove(0);&#125;// 从链表中删除最后一个元素, 返回删除的元素public E removeLast()&#123; return remove(size - 1);&#125;// 从链表中删除元素epublic void removeElement(E e)&#123; Node prev = dummyHead; while(prev.next != null)&#123; if(prev.next.e.equals(e)) break; prev = prev.next; &#125; if(prev.next != null)&#123; Node delNode = prev.next; prev.next = delNode.next; delNode.next = null; size --; &#125;&#125; 单链表的时间复杂度分析添加操作：O(n) addLast(e)：O(n) addFirst(e)：O(1) add(index,e)：O(n/2) 删除操作：O(n) removeLast(e)：O(n) removeFirst(e)：O(1) remove(index,e)：O(n/2) 修改操作：O(n) set(index,e)：O(n) 查找操作：O(n) get(index)：O(n) contains(e)：O(n) 数组和链表的比较数组：优点：使用方便，查询效率比链表高，内存为一连续的区域。 缺点：大小固定，不适合动态存储，不方便动态添加。 动态数组优点：查找方便，适合随机查询。（查询快）。 缺点：插入，删除操作不方便，因为插入，删除操作会导致大量元素的移动。 链表优点：真正的动态，不需要处理固定容量的问题。插入，删除方便，不会导致元素的移动，因为元素增减，只需要调整指针。 缺点：丧失了随机访问的能力（查询慢）。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态数组]]></title>
    <url>%2F2019%2F09%2F08%2F%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[动态数组数组的特点优点： 按照索引查询数据元素速度快 能存储大量数据 按照索引遍历数组方便 缺点： 根据内容查找元素速度慢 数组的大小一经确定不能改变（数组的局限性） 数组只能存储一种类型的数据 增加，删除元素效率慢 未封装任何方法，所有操作都需要用户自己定义 12345678910111213141516171819202122232425262728293031public class Array&lt;E&gt; &#123; private E[] data; private int size; // 构造函数，传入数组的容量capacity构造Array public Array(int capacity)&#123; data = (E[])new Object[capacity]; size = 0; &#125; // 无参数的构造函数，默认数组的容量capacity=10 public Array()&#123; this(10); &#125; // 获取数组的容量 public int getCapacity()&#123; return data.length; &#125; // 获取数组中的元素个数 public int getSize()&#123; return size; &#125; // 返回数组是否为空 public boolean isEmpty()&#123; return size == 0; &#125;&#125; 动态数组使得数组的容量是可以伸缩的。 实现动态数组的思路 定义一个新的容量newCapacity，以新容量开辟一个新数组newData 遍历原数组data的元素，赋值到新数组newData中 将原数组的指针指向新数组 12345678// 将数组空间的容量变成newCapacity大小private void resize(int newCapacity)&#123;E[] newData = (E[])new Object[newCapacity];for(int i = 0 ; i &lt; size ; i ++) newData[i] = data[i]; data = newData;&#125; 动态数组的常见操作添加元素操作1234567891011121314151617181920212223242526// 在index索引的位置插入一个新元素epublic void add(int index, E e)&#123; if(index &lt; 0 || index &gt; size) throw new IllegalArgumentException("Add failed. Require index &gt;= 0 and index &lt;= size."); if(size == data.length) resize(2 * data.length);//扩充数组的容量 for(int i = size - 1; i &gt;= index ; i --) data[i + 1] = data[i]; data[index] = e; size ++;&#125;// 向所有元素后添加一个新元素public void addLast(E e)&#123; add(size, e);&#125;// 在所有元素前添加一个新元素public void addFirst(E e)&#123; add(0, e);&#125; 删除元素操作1234567891011121314151617181920212223242526272829303132// 从数组中删除index位置的元素, 返回删除的元素public E remove(int index)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Remove failed. Index is illegal."); E ret = data[index]; for(int i = index + 1 ; i &lt; size ; i ++) data[i - 1] = data[i]; size --; data[size] = null; // loitering objects != memory leak if(size == data.length / 4 &amp;&amp; data.length / 2 != 0)//为何要如此判断，下面有分析 resize(data.length / 2); return ret;&#125;// 从数组中删除第一个元素, 返回删除的元素public E removeFirst()&#123; return remove(0);&#125;// 从数组中删除最后一个元素, 返回删除的元素public E removeLast()&#123; return remove(size - 1);&#125;// 从数组中删除元素epublic void removeElement(E e)&#123; int index = find(e); if(index != -1) remove(index);&#125; 更改元素操作123456// 修改index索引位置的元素为epublic void set(int index, E e)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Set failed. Index is illegal."); data[index] = e;&#125; 查询元素123456789101112131415161718192021222324// 获取index索引位置的元素public E get(int index)&#123; if(index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Get failed. Index is illegal."); return data[index];&#125;// 查找数组中是否有元素epublic boolean contains(E e)&#123; for(int i = 0 ; i &lt; size ; i ++)&#123; if(data[i].equals(e)) return true; &#125; return false;&#125;// 查找数组中元素e所在的索引，如果不存在元素e，则返回-1public int find(E e)&#123; for(int i = 0 ; i &lt; size ; i ++)&#123; if(data[i].equals(e)) return i; &#125; return -1;&#125; 动态数组时间复杂度分析添加元素操作：O(n) addLast(e)：O(1) addFirst(e)：O(n) add(index,e)：O(n/2) 删除元素操作：O(n) removeLast(e)：O(1) removeFirst(e)：O(n) remove(index,e)：O(n/2) 修改元素操作：已知索引：O(1)；未知索引：O(n) set(index,e)：O(1) 查找元素操作：已知索引O(1)；未知索引O(n) get(index)：O(1) contains(e):：O(n) find(e)：O(n) resize()时间复杂度分析 resize()：O(n) 从均摊复杂度的角度看addLast操作和removeLast操作 假设capacity=n，n+1次addLast，触发resize，而resize操作了n次，所以总共进行2n+1次基本操作，使用均摊复杂度均摊计算，每次addLast操作，进行2次基本操作，时间复杂度为O(1)。同理，我们看removeLast操作，均摊复杂度后的时间复杂度也为O(1). 防止复杂度震荡 出现复杂度震荡的问题描述： 假设现在我们有一个数组，容量是n，并且装满了元素。这时候，我想添加一个元素，显然是需要进行扩容，容量变为2n，耗时O(n)的时间。但是此时，我又删除了一个元素触发了缩容操作，耗时O(n)的时间。当我们每次触发缩容或扩容操作，都会耗费O(n)额复杂度，那么这便是复杂度的震荡。 分析原因：在特殊情况下，我们频繁的添加和删减操作，导致过于着急的去扩容或缩容。 解决方案： 可以采用一种相对懒惰(Lazy机制)的策略。 比如说，一个满的数组，容量n，添加元素需要进行扩容，容量变为2n。但在这时，在进行删除元素后，不立即进行缩容操作，而是再等等。如果后面一直有删除操作的话，删除到整个数组容积的1/4，再触发缩容操作。缩容数组的1/2，而不是直接缩容到1/4。此时，数组中存在1/4的元素，还预留了1/4的空间。通过这样的策略，防止了复杂度的震荡，从而有效的提升整体的性能。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
